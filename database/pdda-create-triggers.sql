SET client_encoding TO 'UTF8';

DROP TRIGGER IF EXISTS xhb_address_bir_tr ON xhb_address CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_address_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.ADDRESS_ID IS NULL THEN

    SELECT nextval('xhb_address_seq')
    INTO STRICT   NEW.ADDRESS_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_address_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_address_bir_tr
	BEFORE INSERT ON xhb_address FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_address_bir_tr();

DROP TRIGGER IF EXISTS xhb_address_bur_tr ON xhb_address CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_address_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_ADDRESS') = 1) THEN

    INSERT INTO AUD_ADDRESS
    VALUES (OLD.ADDRESS_ID,
            OLD.ADDRESS_1,
            OLD.ADDRESS_2,
            OLD.ADDRESS_3,
            OLD.ADDRESS_4,
            OLD.TOWN,
            OLD.COUNTY,
            OLD.POSTCODE,
            OLD.COUNTRY,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_address_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_address_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_address FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_address_bur_tr();

DROP TRIGGER IF EXISTS xhb_blob_bir_tr ON xhb_blob CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_blob_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.BLOB_ID IS NULL THEN

    SELECT nextval('xhb_blob_seq')
    INTO STRICT   NEW.BLOB_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_blob_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_blob_bir_tr
	BEFORE INSERT ON xhb_blob FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_blob_bir_tr();

DROP TRIGGER IF EXISTS xhb_blob_bur_tr ON xhb_blob CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_blob_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_BLOB') = 1) THEN

    INSERT INTO AUD_BLOB(BLOB_ID,
                          BLOB_DATA,
                          LAST_UPDATE_DATE,
                          CREATION_DATE,
                          CREATED_BY,
                          LAST_UPDATED_BY,
                          VERSION,
                          INSERT_EVENT)
                  VALUES (OLD.BLOB_ID,
                          OLD.BLOB_DATA,
                          OLD.LAST_UPDATE_DATE,
                          OLD.CREATION_DATE,
                          OLD.CREATED_BY,
                          OLD.LAST_UPDATED_BY,
                          OLD.VERSION,
                          l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_blob_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_blob_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_blob FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_blob_bur_tr();

DROP TRIGGER IF EXISTS xhb_casediaryfixture_bir_tr ON xhb_case_diary_fixture CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_casediaryfixture_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CASE_DIARY_FIXTURE_ID IS NULL THEN

    SELECT nextval('xhb_case_diary_fixture_seq')
    INTO STRICT   NEW.CASE_DIARY_FIXTURE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_casediaryfixture_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_casediaryfixture_bir_tr
	BEFORE INSERT ON xhb_case_diary_fixture FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_casediaryfixture_bir_tr();

DROP TRIGGER IF EXISTS xhb_casediaryfixture_bur_tr ON xhb_case_diary_fixture CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_casediaryfixture_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

	-- If Listing Date changes then set FXL_RUN_DATE to NULL
	IF OLD.LISTING_DATE <> NEW.LISTING_DATE THEN
		NEW.FXL_RUN_DATE := NULL;
	END IF;

   -- If Venue changes then set FXL_RUN_DATE to NULL
    IF OLD.COURT_SITE_ID <> NEW.COURT_SITE_ID THEN
		NEW.FXL_RUN_DATE := NULL;
	END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CASE_DIARY_FIXTURE') = 1) THEN
	INSERT INTO AUD_CASE_DIARY_FIXTURE(CASE_DIARY_FIXTURE_ID,
		CASE_LISTING_ENTRY_ID,
		LISTING_DATE,
		FIXTURE_NOTICE_REQUIRED,
		HEARING_TYPE_ID,
		LIST_NOTE_PRE_DEFINED_ID,
		LIST_NOTE_TEXT,
		PRE_DEF_NOTE_CLASS_ID,
		FREE_TEXT_NOTE_CLASS_ID,
		VACATION_PRE_DEFINED_RSON_ID,
		VACATION_FREETEXT_REASON,
		STATUS,
		OBS_IND,
		CREATED_BY,
		LAST_UPDATED_BY,
		CREATION_DATE,
		LAST_UPDATE_DATE,
		VERSION,
		DATE_VACATED,
		INSERT_EVENT)
	VALUES (OLD.CASE_DIARY_FIXTURE_ID,
		OLD.CASE_LISTING_ENTRY_ID,
		OLD.LISTING_DATE,
		OLD.FIXTURE_NOTICE_REQUIRED,
		OLD.HEARING_TYPE_ID,
		OLD.LIST_NOTE_PRE_DEFINED_ID,
		OLD.LIST_NOTE_TEXT,
		OLD.PRE_DEF_NOTE_CLASS_ID,
		OLD.FREE_TEXT_NOTE_CLASS_ID,
		OLD.VACATION_PRE_DEFINED_RSON_ID,
		OLD.VACATION_FREETEXT_REASON,
		OLD.STATUS,
		OLD.OBS_IND,
		OLD.CREATED_BY,
		OLD.LAST_UPDATED_BY,
		OLD.CREATION_DATE,
		OLD.LAST_UPDATE_DATE,
		OLD.VERSION,
		OLD.DATE_VACATED,
		l_trig_event);
  END IF;
  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_casediaryfixture_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_casediaryfixture_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_case_diary_fixture FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_casediaryfixture_bur_tr();

DROP TRIGGER IF EXISTS xhb_case_bir_tr ON xhb_case CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CASE_ID IS NULL THEN

    SELECT nextval('xhb_case_seq')
    INTO STRICT   NEW.CASE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_bir_tr
	BEFORE INSERT ON xhb_case FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_bir_tr();

DROP TRIGGER IF EXISTS xhb_case_bur_tr ON xhb_case CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    IF NEW.CASE_ID = OLD.CASE_ID AND
       NEW.COURT_ID = OLD.COURT_ID AND (NEW.CASE_NUMBER = OLD.CASE_NUMBER OR (NEW.CASE_NUMBER IS NULL AND OLD.CASE_NUMBER IS NULL)) AND (NEW.CASE_TYPE = OLD.CASE_TYPE OR (NEW.CASE_TYPE IS NULL AND OLD.CASE_TYPE IS NULL)) AND (NEW.MAG_CONVICTION_DATE = OLD.MAG_CONVICTION_DATE OR (NEW.MAG_CONVICTION_DATE IS NULL AND OLD.MAG_CONVICTION_DATE IS NULL)) AND (NEW.CASE_SUB_TYPE = OLD.CASE_SUB_TYPE OR (NEW.CASE_SUB_TYPE IS NULL AND OLD.CASE_SUB_TYPE IS NULL)) AND (NEW.CASE_TITLE = OLD.CASE_TITLE OR (NEW.CASE_TITLE IS NULL AND OLD.CASE_TITLE IS NULL)) AND (NEW.CASE_DESCRIPTION = OLD.CASE_DESCRIPTION OR (NEW.CASE_DESCRIPTION IS NULL AND OLD.CASE_DESCRIPTION IS NULL)) AND (NEW.LINKED_CASE_ID = OLD.LINKED_CASE_ID OR (NEW.LINKED_CASE_ID IS NULL AND OLD.LINKED_CASE_ID IS NULL)) AND (NEW.BAIL_MAG_CODE = OLD.BAIL_MAG_CODE OR (NEW.BAIL_MAG_CODE IS NULL AND OLD.BAIL_MAG_CODE IS NULL)) AND (NEW.REF_COURT_ID = OLD.REF_COURT_ID OR (NEW.REF_COURT_ID IS NULL AND OLD.REF_COURT_ID IS NULL)) AND (NEW.SEVERED_IND = OLD.SEVERED_IND OR (NEW.SEVERED_IND IS NULL AND OLD.SEVERED_IND IS NULL)) AND (NEW.INDICT_RESP = OLD.INDICT_RESP OR (NEW.INDICT_RESP IS NULL AND OLD.INDICT_RESP IS NULL)) AND (NEW.DATE_IND_REC = OLD.DATE_IND_REC OR (NEW.DATE_IND_REC IS NULL AND OLD.DATE_IND_REC IS NULL)) AND (NEW.PROS_AGENCY_REFERENCE = OLD.PROS_AGENCY_REFERENCE OR (NEW.PROS_AGENCY_REFERENCE IS NULL AND OLD.PROS_AGENCY_REFERENCE IS NULL)) AND (NEW.CASE_CLASS = OLD.CASE_CLASS OR (NEW.CASE_CLASS IS NULL AND OLD.CASE_CLASS IS NULL)) AND (NEW.JUDGE_REASON_FOR_APPEAL = OLD.JUDGE_REASON_FOR_APPEAL OR (NEW.JUDGE_REASON_FOR_APPEAL IS NULL AND OLD.JUDGE_REASON_FOR_APPEAL IS NULL)) AND (NEW.RESULTS_VERIFIED = OLD.RESULTS_VERIFIED OR (NEW.RESULTS_VERIFIED IS NULL AND OLD.RESULTS_VERIFIED IS NULL)) AND (NEW.LENGTH_TAPE = OLD.LENGTH_TAPE OR (NEW.LENGTH_TAPE IS NULL AND OLD.LENGTH_TAPE IS NULL)) AND (NEW.NO_PAGE_PROS_EVIDENCE = OLD.NO_PAGE_PROS_EVIDENCE OR (NEW.NO_PAGE_PROS_EVIDENCE IS NULL AND OLD.NO_PAGE_PROS_EVIDENCE IS NULL)) AND (NEW.NO_PROS_WITNESS = OLD.NO_PROS_WITNESS OR (NEW.NO_PROS_WITNESS IS NULL AND OLD.NO_PROS_WITNESS IS NULL)) AND (NEW.EST_PDH_TRIAL_LENGTH = OLD.EST_PDH_TRIAL_LENGTH OR (NEW.EST_PDH_TRIAL_LENGTH IS NULL AND OLD.EST_PDH_TRIAL_LENGTH IS NULL)) AND (NEW.INDICTMENT_INFO_1 = OLD.INDICTMENT_INFO_1 OR (NEW.INDICTMENT_INFO_1 IS NULL AND OLD.INDICTMENT_INFO_1 IS NULL)) AND (NEW.INDICTMENT_INFO_2 = OLD.INDICTMENT_INFO_2 OR (NEW.INDICTMENT_INFO_2 IS NULL AND OLD.INDICTMENT_INFO_2 IS NULL)) AND (NEW.INDICTMENT_INFO_3 = OLD.INDICTMENT_INFO_3 OR (NEW.INDICTMENT_INFO_3 IS NULL AND OLD.INDICTMENT_INFO_3 IS NULL)) AND (NEW.INDICTMENT_INFO_4 = OLD.INDICTMENT_INFO_4 OR (NEW.INDICTMENT_INFO_4 IS NULL AND OLD.INDICTMENT_INFO_4 IS NULL)) AND (NEW.INDICTMENT_INFO_5 = OLD.INDICTMENT_INFO_5 OR (NEW.INDICTMENT_INFO_5 IS NULL AND OLD.INDICTMENT_INFO_5 IS NULL)) AND (NEW.INDICTMENT_INFO_6 = OLD.INDICTMENT_INFO_6 OR (NEW.INDICTMENT_INFO_6 IS NULL AND OLD.INDICTMENT_INFO_6 IS NULL)) AND (NEW.POLICE_OFFICER_ATTENDING = OLD.POLICE_OFFICER_ATTENDING OR (NEW.POLICE_OFFICER_ATTENDING IS NULL AND OLD.POLICE_OFFICER_ATTENDING IS NULL)) AND (NEW.CPS_CASE_WORKER = OLD.CPS_CASE_WORKER OR (NEW.CPS_CASE_WORKER IS NULL AND OLD.CPS_CASE_WORKER IS NULL)) AND (NEW.EXPORT_CHARGES = OLD.EXPORT_CHARGES OR (NEW.EXPORT_CHARGES IS NULL AND OLD.EXPORT_CHARGES IS NULL)) AND (NEW.MAGISTRATES_CASE_REF = OLD.MAGISTRATES_CASE_REF OR (NEW.MAGISTRATES_CASE_REF IS NULL AND OLD.MAGISTRATES_CASE_REF IS NULL)) AND (NEW.CLASS_CODE = OLD.CLASS_CODE OR (NEW.CLASS_CODE IS NULL AND OLD.CLASS_CODE IS NULL)) AND (NEW.OFFENCE_GROUP_UPDATE = OLD.OFFENCE_GROUP_UPDATE OR (NEW.OFFENCE_GROUP_UPDATE IS NULL AND OLD.OFFENCE_GROUP_UPDATE IS NULL)) AND (NEW.CCC_TRANS_TO_REF_COURT_ID = OLD.CCC_TRANS_TO_REF_COURT_ID OR (NEW.CCC_TRANS_TO_REF_COURT_ID IS NULL AND OLD.CCC_TRANS_TO_REF_COURT_ID IS NULL)) AND (NEW.RECEIPT_TYPE = OLD.RECEIPT_TYPE OR (NEW.RECEIPT_TYPE IS NULL AND OLD.RECEIPT_TYPE IS NULL)) AND (NEW.ccc_trans_from_ref_court_id = OLD.ccc_trans_from_ref_court_id OR (NEW.ccc_trans_from_ref_court_id IS NULL AND OLD.ccc_trans_from_ref_court_id IS NULL)) AND (NEW.date_trans_from = OLD.date_trans_from OR (NEW.date_trans_from IS NULL AND OLD.date_trans_from IS NULL)) AND (NEW.retrial = OLD.retrial OR (NEW.retrial IS NULL AND OLD.retrial IS NULL)) AND (NEW.original_case_number = OLD.original_case_number OR (NEW.original_case_number IS NULL AND OLD.original_case_number IS NULL)) AND (NEW.lc_sent_date = OLD.lc_sent_date OR (NEW.lc_sent_date IS NULL AND OLD.lc_sent_date IS NULL)) AND (NEW.no_cb_pros_witness = OLD.no_cb_pros_witness OR (NEW.no_cb_pros_witness IS NULL AND OLD.no_cb_pros_witness IS NULL)) AND (NEW.no_other_pros_witness = OLD.no_other_pros_witness OR (NEW.no_other_pros_witness IS NULL AND OLD.no_other_pros_witness IS NULL)) AND (NEW.Vulnerable_victim_indicator = OLD.Vulnerable_victim_indicator OR (NEW.Vulnerable_victim_indicator IS NULL AND OLD.Vulnerable_victim_indicator IS NULL)) AND (NEW.public_display_hide = OLD.public_display_hide OR (NEW.public_display_hide IS NULL AND OLD.public_display_hide IS NULL)) AND (NEW.transferred_case = OLD.transferred_case OR (NEW.transferred_case IS NULL and OLD.transferred_case IS NULL)) AND (NEW.transfer_deferred_sentence = OLD.transfer_deferred_sentence OR (NEW.transfer_deferred_sentence IS NULL and OLD.transfer_deferred_sentence IS NULL)) AND (NEW.MONITORING_CATEGORY_ID = OLD.MONITORING_CATEGORY_ID OR (NEW.MONITORING_CATEGORY_ID IS NULL and OLD.MONITORING_CATEGORY_ID IS NULL)) AND (NEW.APPEAL_LODGED_DATE = OLD.APPEAL_LODGED_DATE OR (NEW.APPEAL_LODGED_DATE IS NULL and OLD.APPEAL_LODGED_DATE IS NULL)) AND (NEW.RECEIVED_DATE = OLD.RECEIVED_DATE OR (NEW.RECEIVED_DATE IS NULL and OLD.RECEIVED_DATE IS NULL)) AND (NEW.EITHER_WAY_TYPE = OLD.EITHER_WAY_TYPE OR (NEW.EITHER_WAY_TYPE IS NULL and OLD.EITHER_WAY_TYPE IS NULL)) AND (NEW.TICKET_REQUIRED = OLD.TICKET_REQUIRED OR (NEW.TICKET_REQUIRED IS NULL and OLD.TICKET_REQUIRED IS NULL)) AND (NEW.TICKET_TYPE_CODE = OLD.TICKET_TYPE_CODE OR (NEW.TICKET_TYPE_CODE IS NULL and OLD.TICKET_TYPE_CODE IS NULL)) AND (NEW.COURT_ID_RECEIVING_SITE = OLD.COURT_ID_RECEIVING_SITE OR (NEW.COURT_ID_RECEIVING_SITE IS NULL and OLD.COURT_ID_RECEIVING_SITE IS NULL)) AND (NEW.COMMITTAL_DATE = OLD.COMMITTAL_DATE OR (NEW.COMMITTAL_DATE IS NULL and OLD.COMMITTAL_DATE IS NULL)) AND (NEW.SENT_FOR_TRIAL_DATE = OLD.SENT_FOR_TRIAL_DATE OR (NEW.SENT_FOR_TRIAL_DATE IS NULL and OLD.SENT_FOR_TRIAL_DATE IS NULL)) AND (NEW.NO_DEFENDANTS_FOR_CASE = OLD.NO_DEFENDANTS_FOR_CASE OR (NEW.NO_DEFENDANTS_FOR_CASE IS NULL and OLD.NO_DEFENDANTS_FOR_CASE IS NULL)) AND (NEW.SECURE_COURT = OLD.SECURE_COURT OR (NEW.SECURE_COURT IS NULL and OLD.SECURE_COURT IS NULL)) AND (NEW.PRELIMINARY_DATE_OF_HEARING	= OLD.PRELIMINARY_DATE_OF_HEARING OR (NEW.PRELIMINARY_DATE_OF_HEARING IS NULL and OLD.PRELIMINARY_DATE_OF_HEARING IS NULL)) AND (NEW.ORIGINAL_JPS_1 = OLD.ORIGINAL_JPS_1 OR (NEW.ORIGINAL_JPS_1 IS NULL and OLD.ORIGINAL_JPS_1 IS NULL)) AND (NEW.ORIGINAL_JPS_2 = OLD.ORIGINAL_JPS_2 OR (NEW.ORIGINAL_JPS_2 IS NULL and OLD.ORIGINAL_JPS_2 IS NULL)) AND (NEW.ORIGINAL_JPS_3 = OLD.ORIGINAL_JPS_3 OR (NEW.ORIGINAL_JPS_3 IS NULL and OLD.ORIGINAL_JPS_3 IS NULL)) AND (NEW.ORIGINAL_JPS_4 = OLD.ORIGINAL_JPS_4 OR (NEW.ORIGINAL_JPS_4 IS NULL and OLD.ORIGINAL_JPS_4 IS NULL)) AND (NEW.POLICE_FORCE_CODE = OLD.POLICE_FORCE_CODE OR (NEW.POLICE_FORCE_CODE IS NULL and OLD.POLICE_FORCE_CODE IS NULL)) AND (NEW.MAGCOURT_HEARINGTYPE_REF_ID	= OLD.MAGCOURT_HEARINGTYPE_REF_ID OR (NEW.MAGCOURT_HEARINGTYPE_REF_ID IS NULL and OLD.MAGCOURT_HEARINGTYPE_REF_ID IS NULL)) AND (NEW.CASE_LISTED = OLD.CASE_LISTED OR (NEW.CASE_LISTED IS NULL and OLD.CASE_LISTED IS NULL)) AND (NEW.ORIG_BODY_DECISION_DATE = OLD.ORIG_BODY_DECISION_DATE OR (NEW.ORIG_BODY_DECISION_DATE IS NULL and OLD.ORIG_BODY_DECISION_DATE IS NULL)) AND (NEW.CASE_STATUS = OLD.CASE_STATUS OR (NEW.CASE_STATUS IS NULL and OLD.CASE_STATUS IS NULL)) AND (NEW.VIDEO_LINK_REQUIRED = OLD.VIDEO_LINK_REQUIRED OR (NEW.VIDEO_LINK_REQUIRED IS NULL and OLD.VIDEO_LINK_REQUIRED IS NULL)) AND (NEW.CRACKED_INEFFECTIVE_ID = OLD.CRACKED_INEFFECTIVE_ID OR (NEW.CRACKED_INEFFECTIVE_ID IS NULL and OLD.CRACKED_INEFFECTIVE_ID IS NULL)) AND (NEW.DEFAULT_HEARING_TYPE = OLD.DEFAULT_HEARING_TYPE OR (NEW.DEFAULT_HEARING_TYPE IS NULL and OLD.DEFAULT_HEARING_TYPE IS NULL)) AND (NEW.SECTION28_NAME1 = OLD.SECTION28_NAME1 OR (NEW.SECTION28_NAME1 IS NULL and OLD.SECTION28_NAME1 IS NULL))	AND (NEW.SECTION28_NAME2 = OLD.SECTION28_NAME2 OR (NEW.SECTION28_NAME2 IS NULL and OLD.SECTION28_NAME2 IS NULL))	AND (NEW.SECTION28_PHONE1 = OLD.SECTION28_PHONE1 OR (NEW.SECTION28_PHONE1 IS NULL and OLD.SECTION28_PHONE1 IS NULL)) AND (NEW.SECTION28_PHONE2 = OLD.SECTION28_PHONE2 OR (NEW.SECTION28_PHONE2 IS NULL and OLD.SECTION28_PHONE2 IS NULL)) AND (NEW.DATE_TRANS_TO = OLD.DATE_TRANS_TO OR (NEW.DATE_TRANS_TO IS NULL and OLD.DATE_TRANS_TO IS NULL)) AND (NEW.CASE_GROUP_NUMBER = OLD.CASE_GROUP_NUMBER OR (NEW.CASE_GROUP_NUMBER IS NULL and OLD.CASE_GROUP_NUMBER IS NULL)) AND (NEW.PUB_RUNNING_LIST_ID = OLD.PUB_RUNNING_LIST_ID OR (NEW.PUB_RUNNING_LIST_ID IS NULL and OLD.PUB_RUNNING_LIST_ID IS NULL)) AND (NEW.DATE_CTL_REMINDER_PRINTED = OLD.DATE_CTL_REMINDER_PRINTED OR (NEW.DATE_CTL_REMINDER_PRINTED IS NULL and OLD.DATE_CTL_REMINDER_PRINTED IS NULL)) AND (NEW.DATE_TRANS_RECORDED_TO = OLD.DATE_TRANS_RECORDED_TO OR (NEW.DATE_TRANS_RECORDED_TO IS NULL and OLD.DATE_TRANS_RECORDED_TO IS NULL)) AND (NEW.S28_ELIGIBLE = OLD.S28_ELIGIBLE OR (NEW.S28_ELIGIBLE IS NULL and OLD.S28_ELIGIBLE IS NULL)) AND (NEW.S28_ORDER_MADE = OLD.S28_ORDER_MADE OR (NEW.S28_ORDER_MADE IS NULL and OLD.S28_ORDER_MADE IS NULL)) AND (NEW.TELEVISED_APPLICATION_MADE = OLD.TELEVISED_APPLICATION_MADE OR (NEW.TELEVISED_APPLICATION_MADE IS NULL and OLD.TELEVISED_APPLICATION_MADE IS NULL)) AND (NEW.TELEVISED_APP_MADE_DATE = OLD.TELEVISED_APP_MADE_DATE OR (NEW.TELEVISED_APP_MADE_DATE IS NULL and OLD.TELEVISED_APP_MADE_DATE IS NULL)) AND (NEW.TELEVISED_APP_GRANTED = OLD.TELEVISED_APP_GRANTED OR (NEW.TELEVISED_APP_GRANTED IS NULL and OLD.TELEVISED_APP_GRANTED IS NULL)) AND (NEW.TELEVISED_APP_REFUSED_FREETEXT = OLD.TELEVISED_APP_REFUSED_FREETEXT OR (NEW.TELEVISED_APP_REFUSED_FREETEXT IS NULL and OLD.TELEVISED_APP_REFUSED_FREETEXT IS NULL)) AND (NEW.TELEVISED_REMARKS_FILMED = OLD.TELEVISED_REMARKS_FILMED OR (NEW.TELEVISED_REMARKS_FILMED IS NULL and OLD.TELEVISED_REMARKS_FILMED IS NULL)) AND (NEW.DAR_RETENTION_POLICY_ID = OLD.DAR_RETENTION_POLICY_ID OR (NEW.DAR_RETENTION_POLICY_ID IS NULL AND OLD.DAR_RETENTION_POLICY_ID IS NULL)) AND (NEW.CRP_LAST_UPDATE_DATE = OLD.CRP_LAST_UPDATE_DATE OR (NEW.CRP_LAST_UPDATE_DATE IS NULL AND OLD.CRP_LAST_UPDATE_DATE IS NULL)) AND (NEW.CIVIL_UNREST = OLD.CIVIL_UNREST OR (NEW.CIVIL_UNREST IS NULL AND OLD.CIVIL_UNREST IS NULL))

	   THEN



      -- Only the CHARGE_IMPORT_INDICATOR has changed so do not increase VERSION
      -- This will even come into this section if the CHARGE_IMPORT_INDICATOR column is
      -- updated to the same value with all others staying the same
      -- CTX-4495 HOUSEKEEPING -- CASE_HISTORY FAILURE reuqirement to backdate last_update_date
      --  if new last_update_date is same as old last_update_date i.e. NO change in last_udpate_date
      --      then update last_update_date = SYSDATE
      -- if new last_udpate_date is NULL
      --      then update last_udpate_date = SYSDATE
      -- if new last_update_date is NOT the same as old last_update_date and is NOT NULL
      --   i..e user has updated this field purposely eg: for HOUSEKEEPING ACTIVITIES
      --   update last_update_date with the new last_update_date that the user has updated
      SELECT CASE WHEN  NEW.LAST_UPDATE_DATE=OLD.LAST_UPDATE_DATE THEN LOCALTIMESTAMP WHEN  NEW.LAST_UPDATE_DATE IS NULL THEN LOCALTIMESTAMP  ELSE NEW.LAST_UPDATE_DATE END
      INTO STRICT   NEW.LAST_UPDATE_DATE
;

    ELSE

      -- Other fields have changes so increase VERSION
      SELECT OLD.VERSION + 1,
             CASE WHEN  NEW.LAST_UPDATE_DATE=OLD.LAST_UPDATE_DATE THEN LOCALTIMESTAMP WHEN  NEW.LAST_UPDATE_DATE IS NULL THEN LOCALTIMESTAMP  ELSE NEW.LAST_UPDATE_DATE END
      INTO STRICT   NEW.VERSION,
             NEW.LAST_UPDATE_DATE
;

    END IF;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CASE') = 1) THEN

    INSERT INTO AUD_CASE(
	  CASE_ID,
	  CASE_NUMBER,
	  CASE_TYPE,
	  MAG_CONVICTION_DATE,
	  CASE_SUB_TYPE,
	  CASE_TITLE,
	  CASE_DESCRIPTION,
	  LINKED_CASE_ID,
	  BAIL_MAG_CODE,
	  REF_COURT_ID,
	  COURT_ID,
	  CHARGE_IMPORT_INDICATOR,
	  SEVERED_IND,
	  INDICT_RESP,
	  DATE_IND_REC,
	  PROS_AGENCY_REFERENCE,
	  LAST_UPDATE_DATE,
	  CREATION_DATE,
	  CREATED_BY,
	  LAST_UPDATED_BY,
	  VERSION,
	  CASE_CLASS,
	  JUDGE_REASON_FOR_APPEAL,
	  RESULTS_VERIFIED,
	  LENGTH_TAPE,
	  NO_PAGE_PROS_EVIDENCE,
	  NO_PROS_WITNESS,
	  EST_PDH_TRIAL_LENGTH,
	  INDICTMENT_INFO_1,
	  INDICTMENT_INFO_2,
	  INDICTMENT_INFO_3,
	  INDICTMENT_INFO_4,
	  INDICTMENT_INFO_5,
	  INDICTMENT_INFO_6,
	  POLICE_OFFICER_ATTENDING,
	  CPS_CASE_WORKER,
	  EXPORT_CHARGES,
	  IND_CHANGE_STATUS,
	  MAGISTRATES_CASE_REF,
	  CLASS_CODE,
	  OFFENCE_GROUP_UPDATE,
	  CCC_TRANS_TO_REF_COURT_ID,
	  RECEIPT_TYPE,
	  INSERT_EVENT,
	  CCC_TRANS_FROM_REF_COURT_ID,
	  DATE_TRANS_FROM,
	  RETRIAL,
	  ORIGINAL_CASE_NUMBER,
	  LC_SENT_DATE,
	  NO_CB_PROS_WITNESS,
	  NO_OTHER_PROS_WITNESS,
	  VULNERABLE_VICTIM_INDICATOR,
	  PUBLIC_DISPLAY_HIDE,
	  TRANSFERRED_CASE,
	  TRANSFER_DEFERRED_SENTENCE,
	  MONITORING_CATEGORY_ID,
      APPEAL_LODGED_DATE,
  	  RECEIVED_DATE,
  	  EITHER_WAY_TYPE,
  	  TICKET_REQUIRED,
  	  TICKET_TYPE_CODE,
  	  COURT_ID_RECEIVING_SITE,
  	  COMMITTAL_DATE,
  	  SENT_FOR_TRIAL_DATE,
  	  NO_DEFENDANTS_FOR_CASE,
  	  SECURE_COURT,
  	  PRELIMINARY_DATE_OF_HEARING,
  	  ORIGINAL_JPS_1,
  	  ORIGINAL_JPS_2,
  	  ORIGINAL_JPS_3,
  	  ORIGINAL_JPS_4,
  	  POLICE_FORCE_CODE,
 	  MAGCOURT_HEARINGTYPE_REF_ID,
	  CASE_LISTED,
	  ORIG_BODY_DECISION_DATE,
      CASE_STATUS,
      VIDEO_LINK_REQUIRED,
      CRACKED_INEFFECTIVE_ID,
      DEFAULT_HEARING_TYPE,
      SECTION28_NAME1,
      SECTION28_NAME2,
      SECTION28_PHONE1,
      SECTION28_PHONE2,
      DATE_TRANS_TO,
      CASE_GROUP_NUMBER,
      PUB_RUNNING_LIST_ID,
	  DATE_CTL_REMINDER_PRINTED,
      DATE_TRANS_RECORDED_TO,
      S28_ELIGIBLE,
      S28_ORDER_MADE,
	  TELEVISED_APPLICATION_MADE,
	  TELEVISED_APP_MADE_DATE,
	  TELEVISED_APP_GRANTED,
	  TELEVISED_APP_REFUSED_FREETEXT,
	  TELEVISED_REMARKS_FILMED,
	  DAR_RETENTION_POLICY_ID,
	  CRP_LAST_UPDATE_DATE,
	  CIVIL_UNREST
    ) VALUES (
        OLD.CASE_ID,
        OLD.CASE_NUMBER,
        OLD.CASE_TYPE,
        OLD.MAG_CONVICTION_DATE,
        OLD.CASE_SUB_TYPE,
        OLD.CASE_TITLE,
        OLD.CASE_DESCRIPTION,
        OLD.LINKED_CASE_ID,
        OLD.BAIL_MAG_CODE,
        OLD.REF_COURT_ID,
        OLD.COURT_ID,
        OLD.CHARGE_IMPORT_INDICATOR,
        OLD.SEVERED_IND,
        OLD.INDICT_RESP,
        OLD.DATE_IND_REC,
        OLD.PROS_AGENCY_REFERENCE,
        OLD.LAST_UPDATE_DATE,
        OLD.CREATION_DATE,
        OLD.CREATED_BY,
        OLD.LAST_UPDATED_BY,
        OLD.VERSION,
        OLD.CASE_CLASS,
        OLD.JUDGE_REASON_FOR_APPEAL,
        OLD.RESULTS_VERIFIED,
        OLD.LENGTH_TAPE,
        OLD.NO_PAGE_PROS_EVIDENCE,
        OLD.NO_PROS_WITNESS,
        OLD.EST_PDH_TRIAL_LENGTH,
        OLD.indictment_info_1,
        OLD.indictment_info_2,
        OLD.indictment_info_3,
        OLD.indictment_info_4,
        OLD.indictment_info_5,
        OLD.indictment_info_6,
        OLD.POLICE_OFFICER_ATTENDING,
        OLD.CPS_CASE_WORKER,
        OLD.EXPORT_CHARGES,
        OLD.IND_CHANGE_STATUS,
        OLD.MAGISTRATES_CASE_REF,
        OLD.CLASS_CODE,
        OLD.OFFENCE_GROUP_UPDATE,
        OLD.CCC_TRANS_TO_REF_COURT_ID,
        OLD.RECEIPT_TYPE,
        l_trig_event,
        OLD.ccc_trans_from_ref_court_id,
        OLD.date_trans_from,
        OLD.retrial,
        OLD.original_case_number,
        OLD.lc_sent_date,
        OLD.no_cb_pros_witness,
        OLD.no_other_pros_witness,
        OLD.Vulnerable_victim_indicator,
        OLD.public_display_hide,
        OLD.TRANSFERRED_CASE,
        OLD.TRANSFER_DEFERRED_SENTENCE,
        OLD.MONITORING_CATEGORY_ID,
        OLD.APPEAL_LODGED_DATE,
        OLD.RECEIVED_DATE,
        OLD.EITHER_WAY_TYPE,
        OLD.TICKET_REQUIRED,
        OLD.TICKET_TYPE_CODE,
        OLD.COURT_ID_RECEIVING_SITE,
        OLD.COMMITTAL_DATE,
        OLD.SENT_FOR_TRIAL_DATE,
        OLD.NO_DEFENDANTS_FOR_CASE,
        OLD.SECURE_COURT,
        OLD.PRELIMINARY_DATE_OF_HEARING,
        OLD.ORIGINAL_JPS_1,
        OLD.ORIGINAL_JPS_2,
        OLD.ORIGINAL_JPS_3,
        OLD.ORIGINAL_JPS_4,
        OLD.POLICE_FORCE_CODE,
        OLD.MAGCOURT_HEARINGTYPE_REF_ID,
        OLD.CASE_LISTED,
        OLD.ORIG_BODY_DECISION_DATE,
        OLD.CASE_STATUS,
        OLD.VIDEO_LINK_REQUIRED,
        OLD.CRACKED_INEFFECTIVE_ID,
        OLD.DEFAULT_HEARING_TYPE,
        OLD.SECTION28_NAME1,
        OLD.SECTION28_NAME2,
        OLD.SECTION28_PHONE1,
        OLD.SECTION28_PHONE2,
        OLD.DATE_TRANS_TO,
        OLD.CASE_GROUP_NUMBER,
        OLD.PUB_RUNNING_LIST_ID,
        OLD.DATE_CTL_REMINDER_PRINTED,
        OLD.DATE_TRANS_RECORDED_TO,
        OLD.S28_ELIGIBLE,
        OLD.S28_ORDER_MADE,
        OLD.TELEVISED_APPLICATION_MADE,
        OLD.TELEVISED_APP_MADE_DATE,
        OLD.TELEVISED_APP_GRANTED,
        OLD.TELEVISED_APP_REFUSED_FREETEXT,
        OLD.TELEVISED_REMARKS_FILMED,
        OLD.DAR_RETENTION_POLICY_ID,
        OLD.CRP_LAST_UPDATE_DATE,
		OLD.CIVIL_UNREST);
  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_case FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_bur_tr();

DROP TRIGGER IF EXISTS xhb_case_listing_entry_bir_tr ON xhb_case_listing_entry CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_listing_entry_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CASE_LISTING_ENTRY_ID IS NULL THEN

    SELECT nextval('xhb_case_listing_entry_seq')
    INTO STRICT   NEW.CASE_LISTING_ENTRY_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_listing_entry_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_listing_entry_bir_tr
	BEFORE INSERT ON xhb_case_listing_entry FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_listing_entry_bir_tr();

DROP TRIGGER IF EXISTS xhb_case_listing_entry_bur_tr ON xhb_case_listing_entry CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_listing_entry_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CASE_LISTING_ENTRY') = 1) THEN
	INSERT INTO AUD_CASE_LISTING_ENTRY(CASE_LISTING_ENTRY_ID,
	 	CASE_ID,
	 	REF_JUDGE_TYPE_ID,
	 	COURT_SITE_ID,
	 	COURT_ID,
	 	JUDGE_ID,
		OBS_IND,
		CREATED_BY,
		LAST_UPDATED_BY,
		CREATION_DATE,
		LAST_UPDATE_DATE,
		VERSION,
		INSERT_EVENT)
	VALUES (OLD.CASE_LISTING_ENTRY_ID,
	 	OLD.CASE_ID,
	 	OLD.REF_JUDGE_TYPE_ID,
	 	OLD.COURT_SITE_ID,
	 	OLD.COURT_ID,
	 	OLD.JUDGE_ID,
		OLD.OBS_IND,
		OLD.CREATED_BY,
		OLD.LAST_UPDATED_BY,
		OLD.CREATION_DATE,
		OLD.LAST_UPDATE_DATE,
		OLD.VERSION,
		l_trig_event);
  END IF;


  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_listing_entry_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_listing_entry_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_case_listing_entry FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_listing_entry_bur_tr();

DROP TRIGGER IF EXISTS xhb_case_on_list_bir_tr ON xhb_case_on_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_on_list_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CASE_ON_LIST_ID IS NULL THEN

    SELECT nextval('xhb_case_on_list_seq')
    INTO STRICT   NEW.CASE_ON_LIST_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL)
     OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_on_list_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_on_list_bir_tr
	BEFORE INSERT ON xhb_case_on_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_on_list_bir_tr();

DROP TRIGGER IF EXISTS xhb_case_on_list_bur_tr ON xhb_case_on_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_on_list_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CASE_ON_LIST') = 1) THEN

    INSERT INTO AUD_CASE_ON_LIST(
    CASE_ON_LIST_ID,
    CASE_ID,
    LIST_ID,
    SITTING_ON_LIST_ID,
    COURT_SITE_ID,
    COURT_ROOM_ID,
    RESERVED,
    FLOATER_CASE,
    TIME_MARKING_ID,
    TIME_LISTED,
    IS_COURT_ROOM_LIST_ENTRY,
    HEARING_TYPE_ID,
    REASON_FOR_REMOVAL,
    CRACKED_INEFFECTIVE_ID,
    OBS_IND,
    CREATED_BY,
    LAST_UPDATED_BY,
    CREATION_DATE,
    LAST_UPDATE_DATE,
    VERSION,
    CASE_DIARY_FIXTURE_ID,
    DATE_OF_REMOVAL,
    LIST_NOTE_PREDEFINED_ID,
    LIST_NOTE_TEXT,
    PARENT_CASE_ON_LIST_ID,
    NHA_FIRM_LIST,
	VACATION_PRE_DEFINED_RSON_ID,
    INSERT_EVENT,
    seq_no)
    VALUES (
    OLD.CASE_ON_LIST_ID,
    OLD.CASE_ID,
    OLD.LIST_ID,
    OLD.SITTING_ON_LIST_ID,
    OLD.COURT_SITE_ID,
    OLD.COURT_ROOM_ID,
    OLD.RESERVED,
    OLD.FLOATER_CASE,
    OLD.TIME_MARKING_ID,
    OLD.TIME_LISTED,
    OLD.IS_COURT_ROOM_LIST_ENTRY,
    OLD.HEARING_TYPE_ID,
    OLD.REASON_FOR_REMOVAL,
    OLD.CRACKED_INEFFECTIVE_ID,
    OLD.OBS_IND,
    OLD.CREATED_BY,
    OLD.LAST_UPDATED_BY,
    OLD.CREATION_DATE,
    OLD.LAST_UPDATE_DATE,
    OLD.VERSION,
    OLD.CASE_DIARY_FIXTURE_ID,
    OLD.DATE_OF_REMOVAL,
    OLD.LIST_NOTE_PREDEFINED_ID,
    OLD.LIST_NOTE_TEXT,
    OLD.PARENT_CASE_ON_LIST_ID,
    OLD.NHA_FIRM_LIST,
	OLD.VACATION_PRE_DEFINED_RSON_ID,
    l_trig_event,
    OLD.seq_no);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_on_list_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_on_list_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_case_on_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_on_list_bur_tr();

DROP TRIGGER IF EXISTS xhb_cc_info_bir_tr ON xhb_cc_info CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cc_info_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CC_INFO_ID IS NULL THEN

    SELECT nextval('xhb_cc_info_seq')
    INTO STRICT  NEW.CC_INFO_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cc_info_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cc_info_bir_tr
	BEFORE INSERT ON xhb_cc_info FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cc_info_bir_tr();

DROP TRIGGER IF EXISTS xhb_cc_info_bur_tr ON xhb_cc_info CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cc_info_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CC_INFO') = 1) THEN

    INSERT INTO AUD_CC_INFO
    VALUES (OLD.CC_INFO_ID,
            OLD.CC_INFO_TEXT,
            OLD.VERSION,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cc_info_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cc_info_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_cc_info FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cc_info_bur_tr();

DROP TRIGGER IF EXISTS xhb_clob_bir_tr ON xhb_clob CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_clob_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CLOB_ID IS NULL THEN

    SELECT nextval('xhb_clob_seq')
    INTO STRICT   NEW.CLOB_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_clob_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_clob_bir_tr
	BEFORE INSERT ON xhb_clob FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_clob_bir_tr();

DROP TRIGGER IF EXISTS xhb_clob_bur_tr ON xhb_clob CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_clob_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CLOB') = 1) THEN

    INSERT INTO AUD_CLOB(CLOB_ID,
                          CLOB_DATA,
                          LAST_UPDATE_DATE,
                          CREATION_DATE,
                          CREATED_BY,
                          LAST_UPDATED_BY,
                          VERSION,
                          INSERT_EVENT)
                  VALUES (OLD.CLOB_ID,
                          OLD.CLOB_DATA,
                          OLD.LAST_UPDATE_DATE,
                          OLD.CREATION_DATE,
                          OLD.CREATED_BY,
                          OLD.LAST_UPDATED_BY,
                          OLD.VERSION,
                          l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_clob_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_clob_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_clob FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_clob_bur_tr();

DROP TRIGGER IF EXISTS xhb_courtroom_bir_tr ON xhb_court_room CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_courtroom_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.COURT_ROOM_ID IS NULL THEN

    SELECT nextval('xhb_court_room_seq')
    INTO STRICT   NEW.COURT_ROOM_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_courtroom_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_courtroom_bir_tr
	BEFORE INSERT ON xhb_court_room FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_courtroom_bir_tr();

DROP TRIGGER IF EXISTS xhb_courtroom_bur_tr ON xhb_court_room CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_courtroom_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_COURT_ROOM') = 1) THEN

    INSERT INTO AUD_COURT_ROOM(COURT_ROOM_ID,
                                COURT_ROOM_NAME,
                                DESCRIPTION,
                                CREST_COURT_ROOM_NO,
                                COURT_SITE_ID,
                                LAST_UPDATE_DATE,
                                CREATION_DATE,
                                CREATED_BY,
                                LAST_UPDATED_BY,
                                VERSION,
                                obs_ind,
                                DISPLAY_NAME,
                                INSERT_EVENT,
                                security_ind,
                                video_ind
                                )
    VALUES (OLD.COURT_ROOM_ID,
            OLD.COURT_ROOM_NAME,
            OLD.DESCRIPTION,
            OLD.CREST_COURT_ROOM_NO,
            OLD.COURT_SITE_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.obs_ind,
            OLD.DISPLAY_NAME,
            l_trig_event,
            OLD.security_ind,
            OLD.video_ind
            );

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_courtroom_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_courtroom_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_court_room FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_courtroom_bur_tr();

DROP TRIGGER IF EXISTS xhb_courtsite_bir_tr ON xhb_court_site CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_courtsite_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.COURT_SITE_ID IS NULL THEN

    SELECT nextval('xhb_court_site_seq')
    INTO STRICT   NEW.COURT_SITE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_courtsite_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_courtsite_bir_tr
	BEFORE INSERT ON xhb_court_site FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_courtsite_bir_tr();

DROP TRIGGER IF EXISTS xhb_courtsite_bur_tr ON xhb_court_site CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_courtsite_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_COURT_SITE') = 1) THEN

    INSERT INTO AUD_COURT_SITE(COURT_SITE_ID,
                              COURT_SITE_NAME,
                              COURT_SITE_CODE,
                              COURT_ID,
                              ADDRESS_ID,
                              LAST_UPDATE_DATE,
                              CREATION_DATE,
                              CREATED_BY,
                              LAST_UPDATED_BY,
                              VERSION,
                              obs_ind,
                              DISPLAY_NAME,
                              CREST_COURT_ID,
                              SHORT_NAME,
                              site_group,
                              floater_text,
                              list_name,
			      tier,
                              insert_event
                              )
    VALUES (OLD.COURT_SITE_ID,
            OLD.COURT_SITE_NAME,
            OLD.COURT_SITE_CODE,
            OLD.COURT_ID,
            OLD.ADDRESS_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.obs_ind,
            OLD.DISPLAY_NAME,
            OLD.CREST_COURT_ID,
            OLD.SHORT_NAME,
            OLD.site_group,
            OLD.floater_text,
            OLD.list_name,
	    OLD.tier,
            l_trig_event
            );

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_courtsite_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_courtsite_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_court_site FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_courtsite_bur_tr();

DROP TRIGGER IF EXISTS xhb_court_bir_tr ON xhb_court CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.COURT_ID IS NULL THEN

    SELECT nextval('xhb_court_seq')
    INTO STRICT   NEW.COURT_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_bir_tr
	BEFORE INSERT ON xhb_court FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_bir_tr();

DROP TRIGGER IF EXISTS xhb_court_bur_tr ON xhb_court CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_COURT') = 1) THEN

    INSERT INTO AUD_COURT(COURT_ID,
            COURT_TYPE,
            CIRCUIT,
            COURT_NAME,
            CREST_COURT_ID,
            COURT_PREFIX,
            SHORT_NAME,
            LAST_UPDATE_DATE,
            CREATION_DATE,
            CREATED_BY,
            LAST_UPDATED_BY,
            VERSION,
            ADDRESS_ID,
            CREST_IP_ADDRESS,
            IN_SERVICE_FLAG,
            OBS_IND,
            PROBATION_OFFICE_NAME,
            INTERNET_COURT_NAME,
            DISPLAY_NAME,
            COURT_CODE,
            COUNTRY,
            LANGUAGE,
	          POLICE_FORCE_CODE,
            INSERT_EVENT,
            fl_rep_sort,
            court_start_time,
            wl_rep_sort,
            wl_rep_period,
            wl_rep_time,
            wl_free_text,
			IS_PILOT,
			DX_REF,
			COUNTY_LOC_CODE,
			TIER,
			CPP_COURT)
    VALUES (OLD.COURT_ID,
            OLD.COURT_TYPE,
            OLD.CIRCUIT,
            OLD.COURT_NAME,
            OLD.CREST_COURT_ID,
            OLD.COURT_PREFIX,
            OLD.SHORT_NAME,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.ADDRESS_ID,
            OLD.CREST_IP_ADDRESS,
            OLD.IN_SERVICE_FLAG,
            OLD.OBS_IND,
            OLD.PROBATION_OFFICE_NAME,
            OLD.INTERNET_COURT_NAME,
            OLD.DISPLAY_NAME,
            OLD.COURT_CODE,
            OLD.country,
            OLD.LANGUAGE,
            OLD.POLICE_FORCE_CODE,
            l_trig_event,
            OLD.fl_rep_sort,
            OLD.court_start_time,
            OLD.wl_rep_sort,
            OLD.wl_rep_period,
            OLD.wl_rep_time,
            OLD.wl_free_text,
			OLD.IS_PILOT,
			OLD.DX_REF,
			OLD.COUNTY_LOC_CODE,
			OLD.TIER,
			OLD.CPP_COURT	);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_court FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_bur_tr();

DROP TRIGGER IF EXISTS xhb_court_satellite_bir_tr ON xhb_court_satellite CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_satellite_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.COURT_SATELLITE_ID IS NULL THEN

    SELECT nextval('xhb_court_satellite_seq')
    INTO STRICT   NEW.COURT_SATELLITE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_satellite_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_satellite_bir_tr
	BEFORE INSERT ON xhb_court_satellite FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_satellite_bir_tr();

DROP TRIGGER IF EXISTS xhb_court_satellite_bur_tr ON xhb_court_satellite CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_satellite_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CONNECTED_USER') = 1) THEN

    INSERT INTO AUD_COURT_SATELLITE(
	    COURT_SATELLITE_ID,
            COURT_SITE_ID,
            INTERNET_SATELLITE_NAME,
            LAST_UPDATE_DATE,
            CREATION_DATE,
            CREATED_BY,
            LAST_UPDATED_BY,
            VERSION,
            INSERT_EVENT,
	    OBS_IND)
    VALUES (OLD.COURT_SATELLITE_ID,
            OLD.COURT_SITE_ID,
            OLD.INTERNET_SATELLITE_NAME,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event,
	    OLD.OBS_IND);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_satellite_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_satellite_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_court_satellite FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_satellite_bur_tr();

DROP TRIGGER IF EXISTS xhb_cppformattingmerge_bir_tr ON xhb_cpp_formatting_merge CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cppformattingmerge_bir_tr() RETURNS trigger AS $BODY$
BEGIN


  IF NEW.CPP_FORMATTING_MERGE_ID IS NULL THEN

    SELECT nextval('xhb_cpp_formatting_merge_seq')
    INTO STRICT   NEW.CPP_FORMATTING_MERGE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cppformattingmerge_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cppformattingmerge_bir_tr
	BEFORE INSERT ON xhb_cpp_formatting_merge FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cppformattingmerge_bir_tr();

DROP TRIGGER IF EXISTS xhb_cppformattingmerge_bur_tr ON xhb_cpp_formatting_merge CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cppformattingmerge_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CPP_FORMATTING_MERGE') = 1) THEN

    INSERT INTO AUD_CPP_FORMATTING_MERGE
    VALUES (OLD.CPP_FORMATTING_MERGE_ID,
	OLD.CPP_FORMATTING_ID,
	OLD.FORMATTING_ID,
	OLD.XHIBIT_CLOB_ID,
	OLD.COURT_ID,
	OLD.CREATION_DATE,
	OLD.LANGUAGE,
	OLD.OBS_IND,
	OLD.VERSION,
	OLD.LAST_UPDATE_DATE,
	OLD.LAST_UPDATED_BY,
	OLD.CREATED_BY,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cppformattingmerge_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cppformattingmerge_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_cpp_formatting_merge FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cppformattingmerge_bur_tr();

DROP TRIGGER IF EXISTS xhb_cppformatting_bir_tr ON xhb_cpp_formatting CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cppformatting_bir_tr() RETURNS trigger AS $BODY$
BEGIN


  IF NEW.CPP_FORMATTING_ID IS NULL THEN

    SELECT nextval('xhb_cpp_formatting_seq')
    INTO STRICT   NEW.CPP_FORMATTING_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cppformatting_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cppformatting_bir_tr
	BEFORE INSERT ON xhb_cpp_formatting FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cppformatting_bir_tr();

DROP TRIGGER IF EXISTS xhb_cppformatting_bur_tr ON xhb_cpp_formatting CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cppformatting_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CPP_FORMATTING') = 1) THEN

    INSERT INTO AUD_CPP_FORMATTING
    VALUES (OLD.CPP_FORMATTING_ID,
	OLD.STAGING_TABLE_ID,
	OLD.DATE_IN,
	OLD.FORMAT_STATUS,
	OLD.DOCUMENT_TYPE,
	OLD.COURT_ID,
	OLD.XML_DOCUMENT_CLOB_ID,
	OLD.ERROR_MESSAGE,
	OLD.OBS_IND,
	OLD.VERSION,
	OLD.LAST_UPDATE_DATE,
	OLD.LAST_UPDATED_BY,
	OLD.CREATION_DATE,
	OLD.CREATED_BY,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cppformatting_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cppformatting_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_cpp_formatting FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cppformatting_bur_tr();

DROP TRIGGER IF EXISTS xhb_cppstaginginbound_bir_tr ON xhb_cpp_staging_inbound CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cppstaginginbound_bir_tr() RETURNS trigger AS $BODY$
BEGIN


  IF NEW.CPP_STAGING_INBOUND_ID IS NULL THEN

    SELECT nextval('xhb_cpp_staging_inbound_seq')
    INTO STRICT   NEW.CPP_STAGING_INBOUND_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cppstaginginbound_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cppstaginginbound_bir_tr
	BEFORE INSERT ON xhb_cpp_staging_inbound FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cppstaginginbound_bir_tr();

DROP TRIGGER IF EXISTS xhb_cppstaginginbound_bur_tr ON xhb_cpp_staging_inbound CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cppstaginginbound_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;
/* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CPP_STAGING_INBOUND') = 1) THEN

    INSERT INTO AUD_CPP_STAGING_INBOUND
    VALUES (OLD.CPP_STAGING_INBOUND_ID,
            OLD.DOCUMENT_NAME,
            OLD.COURT_CODE,
            OLD.DOCUMENT_TYPE,
            OLD.TIME_LOADED,
            OLD.CLOB_ID,
            OLD.VALIDATION_STATUS,
            OLD.ACKNOWLEDGMENT_STATUS,
            OLD.PROCESSING_STATUS,
            OLD.VALIDATION_ERROR_MESSAGE,
            OLD.OBS_IND,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;
  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cppstaginginbound_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cppstaginginbound_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_cpp_staging_inbound FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cppstaginginbound_bur_tr();

DROP TRIGGER IF EXISTS xhb_cpp_list_bir_tr ON xhb_cpp_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cpp_list_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CPP_LIST_ID IS NULL THEN

    SELECT nextval('xhb_cpp_list_seq')
    INTO STRICT   NEW.CPP_LIST_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL)
     OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cpp_list_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cpp_list_bir_tr
	BEFORE INSERT ON xhb_cpp_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cpp_list_bir_tr();

DROP TRIGGER IF EXISTS xhb_cpp_list_bur_tr ON xhb_cpp_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cpp_list_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CPP_LIST') = 1) THEN

    INSERT INTO AUD_CPP_LIST
    VALUES (OLD.CPP_LIST_ID,
	OLD.COURT_CODE,
	OLD.LIST_TYPE,
	OLD.TIME_LOADED,
	OLD.LIST_START_DATE,
	OLD.LIST_END_DATE,
	OLD.LIST_CLOB_ID,
	OLD.MERGED_CLOB_ID,
	OLD.STATUS,
	OLD.ERROR_MESSAGE,
	OLD.OBS_IND,
	OLD.LAST_UPDATED_BY,
	OLD.CREATION_DATE,
	OLD.LAST_UPDATE_DATE,
	OLD.CREATED_BY,
	OLD.VERSION,
            l_trig_event);

  END IF;


  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cpp_list_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cpp_list_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_cpp_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cpp_list_bur_tr();


DROP TRIGGER IF EXISTS xhb_formatting_bir_tr ON xhb_formatting CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_formatting_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.FORMATTING_ID IS NULL THEN

    SELECT nextval('xhb_formatting_seq')
    INTO STRICT   NEW.FORMATTING_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_formatting_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_formatting_bir_tr
	BEFORE INSERT ON xhb_formatting FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_formatting_bir_tr();

DROP TRIGGER IF EXISTS xhb_formatting_bur_tr ON xhb_formatting CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_formatting_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('xhb_formatting') = 1) THEN

    INSERT INTO AUD_FORMATTING(formatting_id,
            date_in,
            format_status,
            distribution_type,
            mime_type,
            document_type,
            last_update_date,
            creation_date,
            created_by,
            last_updated_by,
            version,
            COURT_ID,
	    formatted_document_blob_id,
	    xml_document_clob_id,
	    language,
	    country,
 	    major_schema_version,
	    minor_schema_version,
            insert_event)
    VALUES (OLD.formatting_id,
            OLD.date_in,
            OLD.format_status,
            OLD.distribution_type,
            OLD.mime_type,
            OLD.document_type,
            OLD.last_update_date,
            OLD.creation_date,
            OLD.created_by,
            OLD.last_updated_by,
            OLD.version,
            OLD.COURT_ID,
	    OLD.formatted_document_blob_id,
	    OLD.xml_document_clob_id,
	    OLD.language,
	    OLD.country,
	    OLD.major_schema_version,
	    OLD.minor_schema_version,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_formatting_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_formatting_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_formatting FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_formatting_bur_tr();

DROP TRIGGER IF EXISTS xhb_hearinglist_bir_tr ON xhb_hearing_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_hearinglist_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.LIST_ID IS NULL THEN

    SELECT nextval('xhb_hearing_list_seq')
    INTO STRICT   NEW.LIST_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
DROP TRIGGER IF EXISTS xhb_xml_document_bir_tr ON xhb_xml_document CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_xml_document_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.XML_DOCUMENT_ID IS NULL THEN

    SELECT nextval('xhb_xml_document_seq')
    INTO STRICT   NEW.XML_DOCUMENT_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
 -- REVOKE ALL ON FUNCTION trigger_fct_xhb_xml_document_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_xml_document_bir_tr
	BEFORE INSERT ON xhb_xml_document FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_xml_document_bir_tr();

DROP TRIGGER IF EXISTS xhb_xml_document_bur_tr ON xhb_xml_document CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_xml_document_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('xhb_xml_document') = 1) THEN

    INSERT INTO AUD_XML_DOCUMENT(xml_document_id,
            date_created,
	        document_title,
	        xml_document_clob_id,
	        status,
	        document_type,
	        expiry_date,
	        court_id,
	        created_by,
	        creation_date,
	        last_updated_by,
	        last_update_date,
	        version,
            insert_event)
    VALUES (OLD.xml_document_id,
            OLD.date_created,
	        OLD.document_title,
	        OLD.xml_document_clob_id,
	        OLD.status,
	        OLD.document_type,
	        OLD.expiry_date,
	        OLD.court_id,
	        OLD.created_by,
	        OLD.creation_date,
	        OLD.last_updated_by,
	        OLD.last_update_date,
	        OLD.version,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_xml_document_bur_tr() FROM PUBLIC;
CREATE TRIGGER xhb_xml_document_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_xml_document FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_xml_document_bur_tr();
  
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_hearinglist_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_hearinglist_bir_tr
	BEFORE INSERT ON xhb_hearing_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_hearinglist_bir_tr();

DROP TRIGGER IF EXISTS xhb_hearinglist_bur_tr ON xhb_hearing_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_hearinglist_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_HEARING_LIST') = 1) THEN

    INSERT INTO AUD_HEARING_LIST
    VALUES (OLD.LIST_ID,
            OLD.LIST_TYPE,
            OLD.START_DATE,
            OLD.END_DATE,
            OLD.STATUS,
            OLD.EDITION_NO,
            OLD.PUBLISHED_TIME,
            OLD.PRINT_REFERENCE,
            OLD.CREST_LIST_ID,
            OLD.COURT_ID,
            OLD.LIST_COURT_TYPE,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_hearinglist_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_hearinglist_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_hearing_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_hearinglist_bur_tr();

DROP TRIGGER IF EXISTS xhb_hearing_bir_tr ON xhb_hearing CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_hearing_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.HEARING_ID IS NULL THEN

    SELECT nextval('xhb_hearing_seq')
    INTO STRICT   NEW.HEARING_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_hearing_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_hearing_bir_tr
	BEFORE INSERT ON xhb_hearing FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_hearing_bir_tr();

DROP TRIGGER IF EXISTS xhb_hearing_bur_tr ON xhb_hearing CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_hearing_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_HEARING') = 1) THEN

    INSERT INTO AUD_HEARING
    VALUES (OLD.HEARING_ID,
            OLD.CASE_ID,
            OLD.REF_HEARING_TYPE_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.COURT_ID,
            OLD.MP_HEARING_TYPE,
            OLD.last_calculated_duration,
            OLD.hearing_start_date,
            OLD.hearing_end_date,
            OLD.linked_hearing_id,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_hearing_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_hearing_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_hearing FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_hearing_bur_tr();

DROP TRIGGER IF EXISTS xhb_list_bir_tr ON xhb_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_list_bir_tr() RETURNS trigger AS $BODY$
DECLARE
  v_list_id XHB_LIST.LIST_ID%TYPE;
BEGIN
  BEGIN

  IF NEW.LIST_ID IS NULL THEN

    SELECT nextval('xhb_list_seq')
    INTO STRICT   NEW.LIST_ID
;

  END IF;

  v_list_id := xhb_listing_pkg.get_existing_list_id(
                  p_court_id     => NEW.COURT_ID,
                  p_list_type_id => NEW.LIST_TYPE_ID,
                  p_start_date   => NEW.LIST_START_DATE,
                  p_end_date     => NEW.LIST_END_DATE);
  IF coalesce(v_list_id,NEW.LIST_ID) <> NEW.LIST_ID THEN
     RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';
  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL)
     OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_list_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_list_bir_tr
	BEFORE INSERT ON xhb_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_list_bir_tr();

DROP TRIGGER IF EXISTS xhb_list_bur_tr ON xhb_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_list_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_LIST') = 1) THEN

    INSERT INTO AUD_LIST(
      list_id,
      list_type_id,
      list_parent_id,
      court_id,
      draft_or_final,
      list_number,
      list_start_date,
      list_end_date,
	    publish_date,
	    publish_status,
	    publish_error_reason,
	    obs_ind,
      last_update_date,
      creation_date,
      created_by,
      last_updated_by,
      version,
      insert_event)
    VALUES (
      OLD.list_id,
      OLD.list_type_id,
      OLD.list_parent_id,
      OLD.court_id,
      OLD.draft_or_final,
      OLD.list_number,
      OLD.list_start_date,
      OLD.list_end_date,
	    OLD.publish_date,
	    OLD.publish_status,
	    OLD.publish_error_reason,
	    OLD.obs_ind,
      OLD.last_update_date,
      OLD.creation_date,
      OLD.created_by,
      OLD.last_updated_by,
      OLD.version,
      l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_list_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_list_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_list_bur_tr();

DROP TRIGGER IF EXISTS xhb_refcourtreporter_bir_tr ON xhb_ref_court_reporter CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refcourtreporter_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_COURT_REPORTER_ID IS NULL THEN

    SELECT nextval('xhb_ref_court_reporter_seq')
    INTO STRICT   NEW.REF_COURT_REPORTER_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refcourtreporter_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refcourtreporter_bir_tr
	BEFORE INSERT ON xhb_ref_court_reporter FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refcourtreporter_bir_tr();

DROP TRIGGER IF EXISTS xhb_refcourtreporter_bur_tr ON xhb_ref_court_reporter CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refcourtreporter_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_COURT_REPORTER') = 1) THEN

    INSERT INTO AUD_REF_COURT_REPORTER
    VALUES (OLD.REF_COURT_REPORTER_ID,
            OLD.FIRST_NAME,
            OLD.MIDDLE_NAME,
            OLD.SURNAME,
            OLD.CREST_COURT_REPORTER_ID,
            OLD.INITIALS,
            OLD.REPORT_METHOD,
            OLD.OBS_IND,
            OLD.REF_COURT_REPORTER_FIRM_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.COURT_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refcourtreporter_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refcourtreporter_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_court_reporter FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refcourtreporter_bur_tr();

DROP TRIGGER IF EXISTS xhb_refcourt_bir_tr ON xhb_ref_court CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refcourt_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_COURT_ID IS NULL THEN

    SELECT nextval('xhb_ref_court_seq')
    INTO STRICT   NEW.REF_COURT_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refcourt_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refcourt_bir_tr
	BEFORE INSERT ON xhb_ref_court FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refcourt_bir_tr();

DROP TRIGGER IF EXISTS xhb_refcourt_bur_tr ON xhb_ref_court CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refcourt_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_COURT') = 1) THEN

    INSERT INTO AUD_REF_COURT
    VALUES (OLD.REF_COURT_ID,
            OLD.COURT_FULL_NAME,
            OLD.COURT_SHORT_NAME,
            OLD.NAME_PREFIX,
            OLD.COURT_TYPE,
            OLD.CREST_CODE,
            OLD.OBS_IND,
            OLD.IS_PSD,
            OLD.DX_REF,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.ADDRESS_ID,
            OLD.COURT_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refcourt_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refcourt_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_court FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refcourt_bur_tr();

DROP TRIGGER IF EXISTS xhb_refhearingtype_bir_tr ON xhb_ref_hearing_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refhearingtype_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_HEARING_TYPE_ID IS NULL THEN

    SELECT nextval('xhb_ref_hearing_type_seq')
    INTO STRICT   NEW.REF_HEARING_TYPE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refhearingtype_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refhearingtype_bir_tr
	BEFORE INSERT ON xhb_ref_hearing_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refhearingtype_bir_tr();

DROP TRIGGER IF EXISTS xhb_refhearingtype_bur_tr ON xhb_ref_hearing_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refhearingtype_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_HEARING_TYPE') = 1) THEN

    INSERT INTO AUD_REF_HEARING_TYPE
    VALUES (OLD.REF_HEARING_TYPE_ID,
            OLD.HEARING_TYPE_CODE,
            OLD.HEARING_TYPE_DESC,
            OLD.CATEGORY,
            OLD.SEQ_NO,
            OLD.LIST_SEQUENCE,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.COURT_ID,
            OLD.OBS_IND,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refhearingtype_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refhearingtype_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_hearing_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refhearingtype_bur_tr();

DROP TRIGGER IF EXISTS xhb_refjudge_bir_tr ON xhb_ref_judge CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refjudge_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_JUDGE_ID IS NULL THEN

    SELECT nextval('xhb_ref_judge_seq')
    INTO STRICT   NEW.REF_JUDGE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refjudge_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refjudge_bir_tr
	BEFORE INSERT ON xhb_ref_judge FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refjudge_bir_tr();

DROP TRIGGER IF EXISTS xhb_refjudge_bur_tr ON xhb_ref_judge CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refjudge_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_JUDGE') = 1) THEN

    INSERT INTO AUD_REF_JUDGE
    VALUES (OLD.REF_JUDGE_ID,
            OLD.JUDGE_TYPE,
            OLD.CREST_JUDGE_ID,
            OLD.TITLE,
            OLD.FIRST_NAME,
            OLD.MIDDLE_NAME,
            OLD.SURNAME,
            OLD.FULL_LIST_TITLE1,
            OLD.FULL_LIST_TITLE2,
            OLD.FULL_LIST_TITLE3,
            OLD.STATS_CODE,
            OLD.INITIALS,
            OLD.HONOURS,
            OLD.JUD_VERS,
            OLD.OBS_IND,
            OLD.SOURCE_TABLE,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.COURT_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refjudge_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refjudge_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_judge FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refjudge_bur_tr();

DROP TRIGGER IF EXISTS xhb_refjustice_bir_tr ON xhb_ref_justice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refjustice_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_JUSTICE_ID IS NULL THEN

    SELECT nextval('xhb_ref_justice_seq')
    INTO STRICT   NEW.REF_JUSTICE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refjustice_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refjustice_bir_tr
	BEFORE INSERT ON xhb_ref_justice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refjustice_bir_tr();

DROP TRIGGER IF EXISTS xhb_refjustice_bur_tr ON xhb_ref_justice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_refjustice_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_JUSTICE') = 1) THEN

    INSERT INTO AUD_REF_JUSTICE
    VALUES (OLD.REF_JUSTICE_ID,
            OLD.JUSTICE_NAME,
            OLD.CREST_JUSTICE_ID,
            OLD.COURT_ID,
            OLD.PSD_COURT_CODE,
            OLD.TITLE,
            OLD.INITIALS,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.OBS_IND,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_refjustice_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_refjustice_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_justice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_refjustice_bur_tr();

DROP TRIGGER IF EXISTS xhb_reflegalrepresentat_bir_tr ON xhb_ref_legal_representative CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_reflegalrepresentat_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_LEGAL_REP_ID IS NULL THEN

    SELECT nextval('xhb_ref_legal_rep_seq')
    INTO STRICT   NEW.REF_LEGAL_REP_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_reflegalrepresentat_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_reflegalrepresentat_bir_tr
	BEFORE INSERT ON xhb_ref_legal_representative FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_reflegalrepresentat_bir_tr();

DROP TRIGGER IF EXISTS xhb_reflegalrepresentat_bur_tr ON xhb_ref_legal_representative CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_reflegalrepresentat_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_LEGAL_REPRESENTATIVE') = 1) THEN

    INSERT INTO AUD_REF_LEGAL_REPRESENTATIVE
    VALUES (OLD.REF_LEGAL_REP_ID,
            OLD.FIRST_NAME,
            OLD.MIDDLE_NAME,
            OLD.SURNAME,
            OLD.TITLE,
            OLD.INITIALS,
            OLD.LEGAL_REP_TYPE,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.COURT_ID,
            OLD.OBS_IND,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_reflegalrepresentat_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_reflegalrepresentat_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_legal_representative FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_reflegalrepresentat_bur_tr();

DROP TRIGGER IF EXISTS xhb_ref_court_report_f_bir_tr ON xhb_ref_court_reporter_firm CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_court_report_f_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_COURT_REPORTER_FIRM_ID IS NULL THEN

    SELECT nextval('xhb_ref_court_report_f_seq')
    INTO STRICT   NEW.REF_COURT_REPORTER_FIRM_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_court_report_f_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_court_report_f_bir_tr
	BEFORE INSERT ON xhb_ref_court_reporter_firm FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_court_report_f_bir_tr();

DROP TRIGGER IF EXISTS xhb_ref_court_report_f_bur_tr ON xhb_ref_court_reporter_firm CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_court_report_f_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_COURT_REPORTER_FIRM') = 1) THEN

    INSERT INTO AUD_REF_COURT_REPORTER_FIRM
    VALUES (OLD.REF_COURT_REPORTER_FIRM_ID,
            OLD.OBS_IND,
            OLD.DISPLAY_FIRST,
            OLD.DX_REF,
            OLD.VAT_NO,
            OLD.FIRM_NAME,
            OLD.ADDRESS_ID,
            OLD.COURT_ID,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
            OLD.CREST_COURT_REPORTER_FIRM_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_court_report_f_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_court_report_f_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_court_reporter_firm FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_court_report_f_bur_tr();

DROP TRIGGER IF EXISTS xhb_ref_cracked_effect_bir_tr ON xhb_ref_cracked_effective CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_cracked_effect_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_CRACKED_EFFECTIVE_ID IS NULL THEN

    SELECT nextval('xhb_ref_cracked_effective_seq')
    INTO STRICT   NEW.REF_CRACKED_EFFECTIVE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL)
     OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_cracked_effect_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_cracked_effect_bir_tr
	BEFORE INSERT ON xhb_ref_cracked_effective FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_cracked_effect_bir_tr();

DROP TRIGGER IF EXISTS xhb_ref_cracked_effect_bur_tr ON xhb_ref_cracked_effective CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_cracked_effect_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_CRACKED_EFFECTIVE') = 1) THEN

    INSERT INTO AUD_REF_CRACKED_EFFECTIVE(
    REF_CRACKED_EFFECTIVE_ID
    ,CODE
    ,DESCRIPTION
    ,PARTY_RESPONSIBLE
    ,OBS_IND
    ,LAST_UPDATE_DATE
    ,CREATION_DATE
    ,LAST_UPDATED_BY
    ,CREATED_BY
    ,VERSION
    ,TRIAL_CODE_TYPE
    ,insert_event
    )
    VALUES (
    OLD.REF_CRACKED_EFFECTIVE_ID
    ,OLD.CODE
    ,OLD.DESCRIPTION
    ,OLD.PARTY_RESPONSIBLE
    ,OLD.OBS_IND
    ,OLD.LAST_UPDATE_DATE
    ,OLD.CREATION_DATE
    ,OLD.LAST_UPDATED_BY
    ,OLD.CREATED_BY
    ,OLD.VERSION
    ,OLD.TRIAL_CODE_TYPE
    ,l_trig_event
   );

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_cracked_effect_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_cracked_effect_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_cracked_effective FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_cracked_effect_bur_tr();

DROP TRIGGER IF EXISTS xhb_ref_listing_data_bir_tr ON xhb_ref_listing_data CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_listing_data_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_LISTING_DATA_ID IS NULL THEN

    SELECT nextval('xhb_ref_listing_data_seq')
    INTO STRICT   NEW.REF_LISTING_DATA_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_listing_data_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_listing_data_bir_tr
	BEFORE INSERT ON xhb_ref_listing_data FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_listing_data_bir_tr();

DROP TRIGGER IF EXISTS xhb_ref_listing_data_bur_tr ON xhb_ref_listing_data CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_listing_data_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_LISTING_DATA') = 1) THEN
	INSERT INTO AUD_REF_LISTING_DATA(REF_LISTING_DATA_ID,
	 	REF_DATA_TYPE,
	 	REF_DATA_VALUE,
		CREATED_BY,
		LAST_UPDATED_BY,
		CREATION_DATE,
		LAST_UPDATE_DATE,
		VERSION,
		INSERT_EVENT,
                OBS_IND)
	VALUES (OLD.REF_LISTING_DATA_ID,
	 	OLD.REF_DATA_TYPE,
	 	OLD.REF_DATA_VALUE,
		OLD.CREATED_BY,
		OLD.LAST_UPDATED_BY,
		OLD.CREATION_DATE,
		OLD.LAST_UPDATE_DATE,
		OLD.VERSION,
		l_trig_event,
                OLD.OBS_IND);
  END IF;


  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_listing_data_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_listing_data_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_listing_data FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_listing_data_bur_tr();

DROP TRIGGER IF EXISTS xhb_ref_mon_category_bir_tr ON xhb_ref_monitoring_category CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_mon_category_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_MONITORING_CATEGORY_ID IS NULL THEN

    SELECT nextval('xhb_ref_monitoring_cat_seq')
    INTO STRICT   NEW.REF_MONITORING_CATEGORY_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_mon_category_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_mon_category_bir_tr
	BEFORE INSERT ON xhb_ref_monitoring_category FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_mon_category_bir_tr();

DROP TRIGGER IF EXISTS xhb_ref_mon_category_bur_tr ON xhb_ref_monitoring_category CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_mon_category_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_MONITORING_CATEGORY') = 1) THEN
	INSERT INTO AUD_REF_MONITORING_CATEGORY(REF_MONITORING_CATEGORY_ID,
		MONITORING_CATEGORY_CODE,
		MONITORING_CATEGORY_NAME,
		CREATED_BY,
		LAST_UPDATED_BY,
		CREATION_DATE,
		LAST_UPDATE_DATE,
		VERSION,
		INSERT_EVENT)
	VALUES (OLD.REF_MONITORING_CATEGORY_ID,
		OLD.MONITORING_CATEGORY_CODE,
		OLD.MONITORING_CATEGORY_NAME,
		OLD.CREATED_BY,
		OLD.LAST_UPDATED_BY,
		OLD.CREATION_DATE,
		OLD.LAST_UPDATE_DATE,
		OLD.VERSION,
		l_trig_event);
  END IF;


  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_mon_category_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_mon_category_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_monitoring_category FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_mon_category_bur_tr();

DROP TRIGGER IF EXISTS xhb_ref_system_code_bir_tr ON xhb_ref_system_code CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_system_code_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.REF_SYSTEM_CODE_ID IS NULL THEN

    SELECT nextval('xhb_ref_system_code_seq')
    INTO STRICT   NEW.REF_SYSTEM_CODE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_system_code_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_system_code_bir_tr
	BEFORE INSERT ON xhb_ref_system_code FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_system_code_bir_tr();

DROP TRIGGER IF EXISTS xhb_ref_system_code_bur_tr ON xhb_ref_system_code CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_system_code_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_SYSTEM_CODE') = 1) THEN

    INSERT INTO AUD_REF_SYSTEM_CODE
    VALUES (OLD.REF_SYSTEM_CODE_ID,
            OLD.CODE,
            OLD.CODE_TYPE,
            OLD.CODE_TITLE,
            OLD.DE_CODE,
            OLD.REF_CODE_ORDER,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.COURT_ID,
            OLD.OBS_IND,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_system_code_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_system_code_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_system_code FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_system_code_bur_tr();

DROP TRIGGER IF EXISTS xhb_schedheardefend_bir_tr ON xhb_sched_hearing_defendant CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_schedheardefend_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SCHED_HEAR_DEF_ID IS NULL THEN

    SELECT nextval('xhb_scheduled_hearing_def_seq')
    INTO STRICT   NEW.SCHED_HEAR_DEF_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_schedheardefend_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_schedheardefend_bir_tr
	BEFORE INSERT ON xhb_sched_hearing_defendant FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_schedheardefend_bir_tr();

DROP TRIGGER IF EXISTS xhb_schedheardefend_bur_tr ON xhb_sched_hearing_defendant CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_schedheardefend_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SCHED_HEARING_DEFENDANT') = 1) THEN

    INSERT INTO AUD_SCHED_HEARING_DEFENDANT
    VALUES (OLD.SCHED_HEAR_DEF_ID,
            OLD.SCHEDULED_HEARING_ID,
            OLD.DEFENDANT_ON_CASE_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_schedheardefend_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_schedheardefend_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sched_hearing_defendant FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_schedheardefend_bur_tr();

DROP TRIGGER IF EXISTS xhb_scheduledhearing_bir_tr ON xhb_scheduled_hearing CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_scheduledhearing_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SCHEDULED_HEARING_ID IS NULL THEN

    SELECT nextval('xhb_scheduled_hearing_seq')
    INTO STRICT   NEW.SCHEDULED_HEARING_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_scheduledhearing_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_scheduledhearing_bir_tr
	BEFORE INSERT ON xhb_scheduled_hearing FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_scheduledhearing_bir_tr();

DROP TRIGGER IF EXISTS xhb_scheduledhearing_bur_tr ON xhb_scheduled_hearing CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_scheduledhearing_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SCHEDULED_HEARING') = 1) THEN

    INSERT INTO AUD_SCHEDULED_HEARING(
            SCHEDULED_HEARING_ID,
            SEQUENCE_NO,
            NOT_BEFORE_TIME,
            ORIGINAL_TIME,
            LISTING_NOTE,
            HEARING_PROGRESS,
            SITTING_ID,
            HEARING_ID,
            MOVED_FROM,
            LAST_UPDATE_DATE,
            CREATION_DATE,
            CREATED_BY,
            LAST_UPDATED_BY,
            VERSION,
            LINKED_SH_ID,
            END_TIME,
            START_TIME,
            DATE_OF_HEARING,
            IS_CASE_ACTIVE,
            MOVED_FROM_COURT_ROOM_ID,
            ADD_HEARING_USED,
			REF_CRACKED_EFFECTIVE_ID,
            INSERT_EVENT
    ) VALUES (
            OLD.SCHEDULED_HEARING_ID,
            OLD.SEQUENCE_NO,
            OLD.NOT_BEFORE_TIME,
            OLD.ORIGINAL_TIME,
            OLD.LISTING_NOTE,
            OLD.HEARING_PROGRESS,
            OLD.SITTING_ID,
            OLD.HEARING_ID,
            OLD.MOVED_FROM,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.LINKED_SH_ID,
            OLD.END_TIME,
            OLD.START_TIME,
            OLD.DATE_OF_HEARING,
            OLD.IS_CASE_ACTIVE,
            OLD.MOVED_FROM_COURT_ROOM_ID,
            OLD.ADD_HEARING_USED,
			OLD.REF_CRACKED_EFFECTIVE_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_scheduledhearing_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_scheduledhearing_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_scheduled_hearing FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_scheduledhearing_bur_tr();

DROP TRIGGER IF EXISTS xhb_sched_hearing_att_bir_tr ON xhb_sched_hearing_attendee CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sched_hearing_att_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SH_ATTENDEE_ID IS NULL THEN

    SELECT nextval('xhb_sched_hearing_attend_seq')
    INTO STRICT   NEW.SH_ATTENDEE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sched_hearing_att_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sched_hearing_att_bir_tr
	BEFORE INSERT ON xhb_sched_hearing_attendee FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sched_hearing_att_bir_tr();

DROP TRIGGER IF EXISTS xhb_sched_hearing_att_bur_tr ON xhb_sched_hearing_attendee CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sched_hearing_att_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SCHED_HEARING_ATTENDEE') = 1) THEN

    INSERT INTO AUD_SCHED_HEARING_ATTENDEE
    VALUES (OLD.SH_ATTENDEE_ID,
            OLD.ATTENDEE_TYPE,
            OLD.SCHEDULED_HEARING_ID,
            OLD.VERSION,
            OLD.SH_STAFF_ID,
            OLD.SH_JUSTICE_ID,
            OLD.REF_JUDGE_ID,
            OLD.REF_COURT_REPORTER_ID,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            OLD.REF_JUSTICE_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sched_hearing_att_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sched_hearing_att_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sched_hearing_attendee FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sched_hearing_att_bur_tr();

DROP TRIGGER IF EXISTS xhb_sh_judge_bir_tr ON xhb_sh_judge CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_judge_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SH_JUDGE_ID IS NULL THEN

    SELECT nextval('xhb_sh_judge_seq')
    INTO STRICT   NEW.SH_JUDGE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_judge_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_judge_bir_tr
	BEFORE INSERT ON xhb_sh_judge FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_judge_bir_tr();

DROP TRIGGER IF EXISTS xhb_sh_judge_bur_tr ON xhb_sh_judge CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_judge_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SH_JUDGE') = 1) THEN

    INSERT INTO AUD_SH_JUDGE
    VALUES (OLD.SH_JUDGE_ID,
            OLD.DEPUTY_HCJ,
            OLD.REF_JUDGE_ID,
            OLD.VERSION,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            OLD.SH_ATTENDEE_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_judge_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_judge_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sh_judge FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_judge_bur_tr();

DROP TRIGGER IF EXISTS xhb_sh_justice_bir_tr ON xhb_sh_justice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_justice_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SH_JUSTICE_ID IS NULL THEN

    SELECT nextval('xhb_sh_justice_seq')
    INTO STRICT   NEW.SH_JUSTICE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_justice_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_justice_bir_tr
	BEFORE INSERT ON xhb_sh_justice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_justice_bir_tr();

DROP TRIGGER IF EXISTS xhb_sh_justice_bur_tr ON xhb_sh_justice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_justice_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SH_JUSTICE') = 1) THEN

    INSERT INTO AUD_SH_JUSTICE
    VALUES (OLD.SH_JUSTICE_ID,
            OLD.JUSTICE_NAME,
            OLD.VERSION,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            OLD.HEARING_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_justice_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_justice_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sh_justice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_justice_bur_tr();

DROP TRIGGER IF EXISTS xhb_sh_leg_rep_bir_tr ON xhb_sh_leg_rep CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_leg_rep_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SH_LEG_REP_ID IS NULL THEN

    SELECT nextval('xhb_sh_leg_rep_seq')
    INTO STRICT   NEW.SH_LEG_REP_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_leg_rep_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_leg_rep_bir_tr
	BEFORE INSERT ON xhb_sh_leg_rep FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_leg_rep_bir_tr();

DROP TRIGGER IF EXISTS xhb_sh_leg_rep_bur_tr ON xhb_sh_leg_rep CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_leg_rep_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SH_LEG_REP') = 1) THEN

    INSERT INTO AUD_SH_LEG_REP
    VALUES (OLD.SH_LEG_REP_ID,
            OLD.CREST_SEQUENCE_NO,
            OLD.LEGAL_ROLE,
            OLD.IS_SIGNED_IN,
            OLD.SOL_FIRM_OR_REF_LEGAL_REP,
            OLD.SCHED_HEAR_DEF_ID,
            OLD.REF_LEGAL_REP_ID,
            OLD.VERSION,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            OLD.CC_INFO_ID,
            OLD.REF_SOLICITOR_FIRM_ID,
            OLD.REF_DEFENCE_CATEGORY_ID,
            OLD.SCHEDULED_HEARING_ID,
            l_trig_event,
            OLD.SUB_INST,
            OLD.SUBSTITUTED_REF_LEGAL_REP_ID
            );

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_leg_rep_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_leg_rep_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sh_leg_rep FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_leg_rep_bur_tr();

DROP TRIGGER IF EXISTS xhb_sh_staff_bir_tr ON xhb_sh_staff CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_staff_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SH_STAFF_ID IS NULL THEN

    SELECT nextval('xhb_sh_staff_seq')
    INTO STRICT   NEW.SH_STAFF_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_staff_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_staff_bir_tr
	BEFORE INSERT ON xhb_sh_staff FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_staff_bir_tr();

DROP TRIGGER IF EXISTS xhb_sh_staff_bur_tr ON xhb_sh_staff CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sh_staff_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SH_STAFF') = 1) THEN

    INSERT INTO AUD_SH_STAFF
    VALUES (OLD.SH_STAFF_ID,
            OLD.STAFF_ROLE,
            OLD.STAFF_NAME,
            OLD.VERSION,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sh_staff_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sh_staff_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sh_staff FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sh_staff_bur_tr();

DROP TRIGGER IF EXISTS xhb_sitting_bir_tr ON xhb_sitting CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sitting_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SITTING_ID IS NULL THEN

    SELECT nextval('xhb_sitting_seq')
    INTO STRICT   NEW.SITTING_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sitting_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sitting_bir_tr
	BEFORE INSERT ON xhb_sitting FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sitting_bir_tr();

DROP TRIGGER IF EXISTS xhb_sitting_bur_tr ON xhb_sitting CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sitting_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SITTING') = 1) THEN

    INSERT INTO AUD_SITTING
    VALUES (OLD.SITTING_ID,
            OLD.SITTING_SEQUENCE_NO,
            OLD.IS_SITTING_JUDGE,
            OLD.SITTING_TIME,
            OLD.SITTING_NOTE,
            OLD.REF_JUSTICE1_ID,
            OLD.REF_JUSTICE2_ID,
            OLD.REF_JUSTICE3_ID,
            OLD.REF_JUSTICE4_ID,
            OLD.IS_FLOATING,
            OLD.LIST_ID,
            OLD.REF_JUDGE_ID,
            OLD.COURT_ROOM_ID,
            OLD.COURT_SITE_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.JUSTICENAME4,
            OLD.JUSTICENAME3,
            OLD.JUSTICENAME2,
            OLD.JUSTICENAME1,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sitting_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sitting_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sitting FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sitting_bur_tr();

DROP TRIGGER IF EXISTS xhb_sitting_on_list_bir_tr ON xhb_sitting_on_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sitting_on_list_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.SITTING_ON_LIST_ID IS NULL THEN

    SELECT nextval('xhb_sitting_on_list_seq')
    INTO STRICT   NEW.SITTING_ON_LIST_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sitting_on_list_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sitting_on_list_bir_tr
	BEFORE INSERT ON xhb_sitting_on_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sitting_on_list_bir_tr();

DROP TRIGGER IF EXISTS xhb_sitting_on_list_bur_tr ON xhb_sitting_on_list CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sitting_on_list_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_SITTING_ON_LIST') = 1) THEN
	INSERT INTO AUD_SITTING_ON_LIST(SITTING_ON_LIST_ID,
		SITTING_NUMBER,
		LIST_ID,
		TIME_MARKING_ID,
		TIME_LISTED,
		JUDGE_REF_ID,
		JP1,
		JP2,
		JP3,
		JP4,
		LIST_NOTE_PRE_DEFINED_ID,
		LIST_NOTE_TEXT,
		PRE_DEF_NOTE_CLASSIFICATION_ID,
		FREE_TEXT_NOTE_CLASS_ID,
		OBS_IND,
		LAST_UPDATE_DATE,
		CREATION_DATE,
		LAST_UPDATED_BY,
		CREATED_BY,
		VERSION,
        COURT_ROOM_ID,
        COURT_SITE_ID,
		INSERT_EVENT)
	VALUES (OLD.SITTING_ON_LIST_ID,
		OLD.SITTING_NUMBER,
		OLD.LIST_ID,
		OLD.TIME_MARKING_ID,
		OLD.TIME_LISTED,
		OLD.JUDGE_REF_ID,
		OLD.JP1,
		OLD.JP2,
		OLD.JP3,
		OLD.JP4,
		OLD.LIST_NOTE_PRE_DEFINED_ID,
		OLD.LIST_NOTE_TEXT,
		OLD.PRE_DEF_NOTE_CLASSIFICATION_ID,
		OLD.FREE_TEXT_NOTE_CLASS_ID,
		OLD.OBS_IND,
		OLD.LAST_UPDATE_DATE,
		OLD.CREATION_DATE,
		OLD.LAST_UPDATED_BY,
		OLD.CREATED_BY,
		OLD.VERSION,
        OLD.COURT_ROOM_ID,
        OLD.COURT_SITE_ID,
		l_trig_event);
  END IF;
  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sitting_on_list_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sitting_on_list_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_sitting_on_list FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sitting_on_list_bur_tr();

DROP TRIGGER IF EXISTS xhb_sys_audit_bir_tr ON xhb_sys_audit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_sys_audit_bir_tr() RETURNS trigger AS $BODY$
DECLARE

BEGIN

  IF NEW.SYS_AUDIT_ID IS NULL THEN

    SELECT nextval('xhb_sys_audit_seq')
    INTO STRICT   NEW.SYS_AUDIT_ID
;

  END IF;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_sys_audit_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_sys_audit_bir_tr
	BEFORE INSERT ON xhb_sys_audit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_sys_audit_bir_tr();


DROP TRIGGER IF EXISTS xhb_pdda_message_bir_tr ON xhb_pdda_message CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_pdda_message_bir_tr() RETURNS trigger AS $BODY$
BEGIN

IF NEW.PDDA_MESSAGE_ID IS NULL THEN

  SELECT nextval('xhb_pdda_message_seq')
  INTO STRICT   NEW.PDDA_MESSAGE_ID
;

END IF;

IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

  SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
         coalesce(current_setting('SESSION_USER', true),'PDDA')
  INTO STRICT   NEW.LAST_UPDATED_BY,
         NEW.CREATED_BY
;

END IF;

SELECT LOCALTIMESTAMP,
       LOCALTIMESTAMP,
       1
INTO STRICT   NEW.LAST_UPDATE_DATE,
       NEW.CREATION_DATE,
       NEW.VERSION
;

RETURN NEW;
END
$BODY$
LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ppda_message_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_pdda_message_bir_tr
BEFORE INSERT ON xhb_pdda_message FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_xhb_pdda_message_bir_tr();

DROP TRIGGER IF EXISTS xhb_pdda_message_bur_tr ON xhb_pdda_message CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_pdda_message_bur_tr() RETURNS trigger AS $BODY$
DECLARE

l_trig_event varchar(1) := NULL;
BEGIN
BEGIN

/* Determine whether UPDATING or DELETING */

IF TG_OP = 'UPDATE' THEN

  l_trig_event := 'U';

  /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

  IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

    IF (OLD.VERSION != NEW.VERSION) THEN
    /* Someone has pulled the rug out from below! */

      RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

    END IF;

  END IF;

  SELECT OLD.VERSION + 1,
         LOCALTIMESTAMP
  INTO STRICT   NEW.VERSION,
         NEW.LAST_UPDATE_DATE
;

  /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

  IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY
;

  END IF;

ELSE -- Must be DELETING
  l_trig_event := 'D';

END IF;

/* Is Auditing on this table required */

IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_PDDA_MESSAGE') = 1) THEN

  INSERT INTO AUD_PDDA_MESSAGE
  VALUES (OLD.PDDA_MESSAGE_ID,
          OLD.COURT_ID,
          OLD.COURT_ROOM_ID,
          OLD.PDDA_MESSAGE_GUID,
          OLD.PDDA_MESSAGE_TYPE_ID,
          OLD.PDDA_MESSAGE_DATA_ID,
          OLD.PDDA_BATCH_ID,
          OLD.TIME_SENT,
          OLD.CP_DOCUMENT_NAME,
          OLD.CP_DOCUMENT_STATUS,
          OLD.CP_RESPONSE_GENERATED,
          OLD.CPP_STAGING_INBOUND_ID,
          OLD.ERROR_MESSAGE,
          OLD.OBS_IND,
          OLD.LAST_UPDATE_DATE,
          OLD.CREATION_DATE,
          OLD.CREATED_BY,
          OLD.LAST_UPDATED_BY,
          OLD.VERSION,
          l_trig_event);

END IF;

END;
IF TG_OP = 'DELETE' THEN
RETURN OLD;
ELSE
RETURN NEW;
END IF;

END
$BODY$
LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_pdda_message_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_pdda_message_bur_tr
BEFORE UPDATE OR DELETE ON xhb_pdda_message FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_xhb_pdda_message_bur_tr();


DROP TRIGGER IF EXISTS xhb_ref_pdda_msg_type_bir_tr ON xhb_ref_pdda_message_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_pdda_msg_type_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.PDDA_MESSAGE_TYPE_ID IS NULL THEN

    SELECT nextval('xhb_ref_pdda_message_type_seq')
    INTO STRICT   NEW.PDDA_MESSAGE_TYPE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_pdda_msg_type_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_pdda_msg_type_bir_tr
	BEFORE INSERT ON xhb_ref_pdda_message_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_pdda_msg_type_bir_tr();

DROP TRIGGER IF EXISTS xhb_ref_pdda_msg_type_bur_tr ON xhb_ref_pdda_message_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_ref_pdda_msg_type_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_REF_PDDA_MESSAGE_TYPE') = 1) THEN

    INSERT INTO AUD_REF_PDDA_MESSAGE_TYPE
    VALUES (OLD.PDDA_MESSAGE_TYPE_ID,
            OLD.MESSAGE_TYPE,
            OLD.MESSAGE_TYPE_DESCRIPTION,
            OLD.OBS_IND,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_ref_pdda_msg_type_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_ref_pdda_msg_type_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_ref_pdda_message_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_ref_pdda_msg_type_bur_tr();


DROP TRIGGER IF EXISTS xhb_case_reference_bir_tr ON xhb_case_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_reference_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CASE_REFERENCE_ID IS NULL THEN

    SELECT nextval('xhb_case_reference_seq')
    INTO STRICT   NEW.CASE_REFERENCE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_reference_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_reference_bir_tr
	BEFORE INSERT ON xhb_case_reference FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_reference_bir_tr();

DROP TRIGGER IF EXISTS xhb_case_reference_bur_tr ON xhb_case_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_case_reference_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CASE_REFERENCE') = 1) THEN

    INSERT INTO AUD_CASE_REFERENCE
    VALUES (OLD.CASE_REFERENCE_ID,
            OLD.REPORTING_RESTRICTIONS,
            OLD.CASE_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_case_reference_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_case_reference_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_case_reference FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_case_reference_bur_tr();

DROP TRIGGER IF EXISTS xhb_configuredpublicnot_bir_tr ON xhb_configured_public_notice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_configuredpublicnot_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CONFIGURED_PUBLIC_NOTICE_ID IS NULL THEN

    SELECT nextval('xhb_configured_public_not_seq')
    INTO STRICT   NEW.CONFIGURED_PUBLIC_NOTICE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_configuredpublicnot_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_configuredpublicnot_bir_tr
	BEFORE INSERT ON xhb_configured_public_notice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_configuredpublicnot_bir_tr();

DROP TRIGGER IF EXISTS xhb_configuredpublicnot_bur_tr ON xhb_configured_public_notice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_configuredpublicnot_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_CONFIGURED_PUBLIC_NOTICE') = 1) THEN

    INSERT INTO AUD_CONFIGURED_PUBLIC_NOTICE
    VALUES (OLD.CONFIGURED_PUBLIC_NOTICE_ID,
            OLD.IS_ACTIVE,
            OLD.COURT_ROOM_ID,
            OLD.PUBLIC_NOTICE_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_configuredpublicnot_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_configuredpublicnot_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_configured_public_notice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_configuredpublicnot_bur_tr();

DROP TRIGGER IF EXISTS xhb_court_log_entry_bir_tr ON xhb_court_log_entry CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_log_entry_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.ENTRY_ID IS NULL THEN

    SELECT nextval('xhb_court_log_entry_seq')
    INTO STRICT   NEW.ENTRY_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_log_entry_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_log_entry_bir_tr
	BEFORE INSERT ON xhb_court_log_entry FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_log_entry_bir_tr();

DROP TRIGGER IF EXISTS xhb_court_log_entry_bur_tr ON xhb_court_log_entry CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_log_entry_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_COURT_LOG_ENTRY') = 1) THEN

    INSERT INTO AUD_COURT_LOG_ENTRY
    VALUES (OLD.ENTRY_ID,
            OLD.CASE_ID,
            OLD.VERSION,
            OLD.LAST_UPDATED_BY,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            OLD.DATE_TIME,
            OLD.EVENT_DESC_ID,
            OLD.LOG_ENTRY_XML,
            OLD.DEFENDANT_ON_CASE_ID,
            OLD.DEFENDANT_ON_OFFENCE_ID,
            OLD.SCHEDULED_HEARING_ID,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_log_entry_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_log_entry_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_court_log_entry FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_log_entry_bur_tr();

DROP TRIGGER IF EXISTS xhb_court_log_event_dsc_bir_tr ON xhb_court_log_event_desc CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_log_event_dsc_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.EVENT_DESC_ID IS NULL THEN

    SELECT nextval('xhb_court_log_event_desc_seq')
    INTO STRICT   NEW.EVENT_DESC_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_log_event_dsc_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_log_event_dsc_bir_tr
	BEFORE INSERT ON xhb_court_log_event_desc FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_log_event_dsc_bir_tr();

DROP TRIGGER IF EXISTS xhb_court_log_event_dsc_bur_tr ON xhb_court_log_event_desc CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_court_log_event_dsc_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_COURT_LOG_EVENT_DESC') = 1) THEN

    INSERT INTO AUD_COURT_LOG_EVENT_DESC
    VALUES (OLD.EVENT_DESC_ID,
            OLD.FLAGGED_EVENT,
            OLD.EDITABLE,
            OLD.SEND_TO_MERCATOR,
            OLD.UPDATE_LINKED_CASES,
            OLD.PUBLISH_TO_SUBSCRIBERS,
            OLD.CLEAR_PUBLIC_DISPLAYS,
            OLD.E_INFORM,
            OLD.PUBLIC_DISPLAY,
            OLD.LINKED_CASE_TEXT,
            OLD.EVENT_DESCRIPTION,
            OLD.VERSION,
            OLD.LAST_UPDATED_BY,
            OLD.EVENT_TYPE,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATE_DATE,
            OLD.PUBLIC_NOTICE,
            OLD.SHORT_DESCRIPTION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_court_log_event_dsc_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_court_log_event_dsc_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_court_log_event_desc FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_court_log_event_dsc_bur_tr();

DROP TRIGGER IF EXISTS xhb_cr_live_display_bir_tr ON xhb_cr_live_display CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cr_live_display_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.CR_LIVE_DISPLAY_ID IS NULL THEN

    SELECT nextval('xhb_cr_live_display_seq')
    INTO STRICT   NEW.CR_LIVE_DISPLAY_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cr_live_display_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cr_live_display_bir_tr
	BEFORE INSERT ON xhb_cr_live_display FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cr_live_display_bir_tr();

DROP TRIGGER IF EXISTS xhb_cr_live_display_bur_tr ON xhb_cr_live_display CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_cr_live_display_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

        SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
        INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (Xhb_Custom_Pkg.IS_AUDIT_REQUIRED('XHB_CR_LIVE_DISPLAY') = 1) THEN

    INSERT INTO AUD_CR_LIVE_DISPLAY(CR_LIVE_DISPLAY_ID,
	    COURT_ROOM_ID,
	    SCHEDULED_HEARING_ID,
	    TIME_STATUS_SET,
	    STATUS,
	    CREATED_BY,
	    CREATION_DATE,
	    LAST_UPDATED_BY,
 	    LAST_UPDATE_DATE,
	    VERSION,
	    INSERT_EVENT)
    VALUES (OLD.CR_LIVE_DISPLAY_ID,
            OLD.COURT_ROOM_ID,
            OLD.SCHEDULED_HEARING_ID,
            OLD.TIME_STATUS_SET,
            OLD.STATUS,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_cr_live_display_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_cr_live_display_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_cr_live_display FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_cr_live_display_bur_tr();

DROP TRIGGER IF EXISTS xhb_defendantoncase_bir_tr ON xhb_defendant_on_case CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_defendantoncase_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.DEFENDANT_ON_CASE_ID IS NULL THEN

    SELECT nextval('xhb_defendant_on_case_seq')
    INTO STRICT   NEW.DEFENDANT_ON_CASE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_defendantoncase_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_defendantoncase_bir_tr
	BEFORE INSERT ON xhb_defendant_on_case FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_defendantoncase_bir_tr();

DROP TRIGGER IF EXISTS xhb_defendantoncase_bur_tr ON xhb_defendant_on_case CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_defendantoncase_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
  l_ignore_audit	varchar(1) := 'N';
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

	l_trig_event := 'U';

	IF (OLD.DIFFERENCE_REPORT != NEW.DIFFERENCE_REPORT)
	OR (OLD.DIFFERENCE_REPORT IS NULL AND NEW.DIFFERENCE_REPORT IS NOT NULL)
	OR (OLD.DIFFERENCE_REPORT IS NOT NULL AND NEW.DIFFERENCE_REPORT IS NULL) THEN
		l_ignore_audit := 'Y';
	ELSIF (OLD.COA_STATUS != NEW.COA_STATUS)
	OR (OLD.COA_STATUS IS NULL AND NEW.COA_STATUS IS NOT NULL)
	OR (OLD.COA_STATUS IS NOT NULL AND NEW.COA_STATUS IS NULL) THEN
		l_ignore_audit := 'Y';
	ELSE

		/* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

		IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

		  IF (OLD.VERSION != NEW.VERSION) THEN
		  /* Someone has pulled the rug out from below! */

			RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

		  END IF;

		END IF;

		SELECT OLD.VERSION + 1,
			   LOCALTIMESTAMP
		INTO STRICT   NEW.VERSION,
			   NEW.LAST_UPDATE_DATE
		;

		/* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

		IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

		  SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
		  INTO STRICT   NEW.LAST_UPDATED_BY
		;

		END IF;
	END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DEFENDANT_ON_CASE') = 1 AND l_ignore_audit = 'N') THEN

    INSERT INTO AUD_DEFENDANT_ON_CASE(DEFENDANT_ON_CASE_ID,
		NO_OF_TICS,
		FINAL_DRIVING_LICENCE_STATUS,
		PTIURN,
		IS_JUVENILE,
		IS_MASKED,
		MASKED_NAME,
		CASE_ID,
		DEFENDANT_ID,
		LAST_UPDATE_DATE,
		CREATION_DATE,
		CREATED_BY,
		LAST_UPDATED_BY,
		VERSION,
		OBS_IND,
		RESULTS_VERIFIED,
		DEFENDANT_NUMBER,
		DATE_OF_COMMITTAL,
		PNC_ID,
		COLLECT_MAGISTRATE_COURT_ID,
		INSERT_EVENT,
		CURRENT_BC_STATUS,
		ASN,
		BENCH_WARRANT_EXEC_DATE,
		COMM_BC_STATUS,
		BC_STATUS_BW_EXECUTED,
		SPECIAL_CIR_FOUND,
		CUSTODIAL,
		SUSPENDED,
		SERIOUS_DRUG_OFFENCE,
		RECOMMENDED_DEPORTATION,
		DATE_EXPORTED,
		FIRST_FIXED_TRIAL,
		FIRST_HEARING_TYPE,
        NATIONALITY,
		PUBLIC_DISPLAY_HIDE,
		AMENDED_DATE_EXPORTED,
		AMENDED_REASON,
		HATE_IND,
		HATE_TYPE,
		HATE_SENT_IND,
		DRIVING_DISQ_SUSPENDED_DATE,
		MAG_COURT_FIRST_HEARING_DATE,
		MAG_COURT_FINAL_HEARING_DATE,
		CUSTODY_TIME_LIMIT,
		FORM_NG_SENT_DATE,
		CACD_APPEAL_RESULT_DATE,
		SECTION28_NAME1,
		SECTION28_NAME2,
		SECTION28_PHONE1,
		SECTION28_PHONE2,
		DIFFERENCE_REPORT,
   		DATE_RCPT_NOTICE_APPEAL,
    	CACD_APPEAL_RESULT,
    	COA_STATUS,
		CTL_APPLIES,
		DAR_RETENTION_POLICY_ID)
    VALUES (OLD.DEFENDANT_ON_CASE_ID,
		OLD.NO_OF_TICS,
		OLD.FINAL_DRIVING_LICENCE_STATUS,
		OLD.PTIURN,
		OLD.IS_JUVENILE,
		OLD.IS_MASKED,
		OLD.MASKED_NAME,
		OLD.CASE_ID,
		OLD.DEFENDANT_ID,
		OLD.LAST_UPDATE_DATE,
		OLD.CREATION_DATE,
		OLD.CREATED_BY,
		OLD.LAST_UPDATED_BY,
		OLD.VERSION,
		OLD.OBS_IND,
		OLD.RESULTS_VERIFIED,
		OLD.DEFENDANT_NUMBER,
		OLD.DATE_OF_COMMITTAL,
		OLD.PNC_ID,
		OLD.COLLECT_MAGISTRATE_COURT_ID,
		l_trig_event,
		OLD.CURRENT_BC_STATUS,
		OLD.ASN,
		OLD.BENCH_WARRANT_EXEC_DATE,
		OLD.COMM_BC_STATUS,
		OLD.BC_STATUS_BW_EXECUTED,
		OLD.SPECIAL_CIR_FOUND,
		OLD.CUSTODIAL,
		OLD.SUSPENDED,
		OLD.SERIOUS_DRUG_OFFENCE,
		OLD.RECOMMENDED_DEPORTATION,
		OLD.DATE_EXPORTED,
		OLD.FIRST_FIXED_TRIAL,
		OLD.FIRST_HEARING_TYPE,
        OLD.NATIONALITY,
		OLD.PUBLIC_DISPLAY_HIDE,
		OLD.AMENDED_DATE_EXPORTED,
		OLD.AMENDED_REASON,
		OLD.HATE_IND,
		OLD.HATE_TYPE,
		OLD.HATE_SENT_IND,
		OLD.DRIVING_DISQ_SUSPENDED_DATE,
		OLD.MAG_COURT_FIRST_HEARING_DATE,
		OLD.MAG_COURT_FINAL_HEARING_DATE,
		OLD.CUSTODY_TIME_LIMIT,
		OLD.FORM_NG_SENT_DATE,
		OLD.CACD_APPEAL_RESULT_DATE,
		OLD.SECTION28_NAME1,
		OLD.SECTION28_NAME2,
		OLD.SECTION28_PHONE1,
		OLD.SECTION28_PHONE2,
		OLD.DIFFERENCE_REPORT,
		OLD.DATE_RCPT_NOTICE_APPEAL,
		OLD.CACD_APPEAL_RESULT,
		OLD.COA_STATUS,
		OLD.CTL_APPLIES,
		OLD.DAR_RETENTION_POLICY_ID
    );

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_defendantoncase_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_defendantoncase_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_defendant_on_case FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_defendantoncase_bur_tr();

DROP TRIGGER IF EXISTS xhb_defendant_bir_tr ON xhb_defendant CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_defendant_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.DEFENDANT_ID IS NULL THEN

    SELECT nextval('xhb_defendant_seq')
    INTO STRICT   NEW.DEFENDANT_ID
;

  END IF;

  IF NEW.CREST_DEFENDANT_ID IS NULL THEN

    SELECT NEW.DEFENDANT_ID
    INTO STRICT   NEW.CREST_DEFENDANT_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_defendant_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_defendant_bir_tr
	BEFORE INSERT ON xhb_defendant FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_defendant_bir_tr();

DROP TRIGGER IF EXISTS xhb_defendant_bur_tr ON xhb_defendant CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_defendant_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DEFENDANT') = 1) THEN

    INSERT INTO AUD_DEFENDANT(
	  DEFENDANT_ID,
	  CREST_DEFENDANT_ID,
	  FIRST_NAME,
	  MIDDLE_NAME,
	  SURNAME,
	  INITIALS,
	  DATE_OF_BIRTH,
	  GENDER,
	  LAST_CONVICTION_DATE,
	  IS_COMPANY,
	  LAST_UPDATE_DATE,
	  CREATION_DATE,
	  CREATED_BY,
	  LAST_UPDATED_BY,
	  VERSION,
	  ADDRESS_ID,
	  COURT_ID,
	  PRISON_ID,
	  INSERT_EVENT,
	  PUBLIC_DISPLAY_HIDE,
	  PARENT_GUARDIAN_NAME,
	  ETHNIC_APPEARANCE_CODE,
	  ETHNICITY_SELF_DEFINED,
	  CURRENT_PRISON_STATUS
    ) VALUES (OLD.DEFENDANT_ID,
            OLD.CREST_DEFENDANT_ID,
            OLD.FIRST_NAME,
            OLD.MIDDLE_NAME,
            OLD.SURNAME,
            OLD.INITIALS,
            OLD.DATE_OF_BIRTH,
            OLD.GENDER,
            OLD.LAST_CONVICTION_DATE,
            OLD.IS_COMPANY,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.ADDRESS_ID,
            OLD.COURT_ID,
            OLD.PRISON_ID,
            l_trig_event,
	    OLD.PUBLIC_DISPLAY_HIDE,
	    OLD.PARENT_GUARDIAN_NAME,
	    OLD.ETHNIC_APPEARANCE_CODE,
	    OLD.ETHNICITY_SELF_DEFINED,
   	    OLD.CURRENT_PRISON_STATUS);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_defendant_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_defendant_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_defendant FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_defendant_bur_tr();

DROP TRIGGER IF EXISTS xhb_definitive_public_n_bir_tr ON xhb_definitive_public_notice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_definitive_public_n_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.DEFINITIVE_PN_ID IS NULL THEN

    SELECT nextval('xhb_definitive_pub_notice_seq')
    INTO STRICT   NEW.DEFINITIVE_PN_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_definitive_public_n_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_definitive_public_n_bir_tr
	BEFORE INSERT ON xhb_definitive_public_notice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_definitive_public_n_bir_tr();

DROP TRIGGER IF EXISTS xhb_definitive_public_n_bur_tr ON xhb_definitive_public_notice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_definitive_public_n_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DEFINITIVE_PUBLIC_NOTICE') = 1) THEN

    INSERT INTO AUD_DEFINITIVE_PUBLIC_NOTICE
    VALUES (OLD.definitive_pn_id,
            OLD.definitive_pn_desc,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.priority,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_definitive_public_n_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_definitive_public_n_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_definitive_public_notice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_definitive_public_n_bur_tr();

DROP TRIGGER IF EXISTS xhb_display_bir_tr ON xhb_display CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.DISPLAY_ID IS NULL THEN

    SELECT nextval('xhb_display_seq')
    INTO STRICT   NEW.DISPLAY_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_bir_tr
	BEFORE INSERT ON xhb_display FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_bir_tr();

DROP TRIGGER IF EXISTS xhb_display_bur_tr ON xhb_display CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY') = 1) THEN

    INSERT INTO AUD_DISPLAY
    VALUES (OLD.DISPLAY_ID,
            OLD.DISPLAY_TYPE_ID,
            OLD.DISPLAY_LOCATION_ID,
            OLD.ROTATION_SET_ID,
            OLD.DESCRIPTION_CODE,
            OLD.LOCALE,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
            OLD.SHOW_UNASSIGNED_YN,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_display FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_bur_tr();

DROP TRIGGER IF EXISTS xhb_display_court_room_bdr_tr ON xhb_display_court_room CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_court_room_bdr_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event     varchar(1) := 'D';
  l_modifying_user varchar(30);

BEGIN

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY_COURT_ROOM') = 1) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   l_modifying_user
;

    INSERT INTO AUD_DISPLAY_COURT_ROOM
    VALUES (OLD.DISPLAY_ID,
            OLD.COURT_ROOM_ID,
            l_modifying_user,
            l_trig_event);

  END IF;

RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_court_room_bdr_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_court_room_bdr_tr
	BEFORE DELETE ON xhb_display_court_room FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_court_room_bdr_tr();

DROP TRIGGER IF EXISTS xhb_display_court_room_bir_tr ON xhb_display_court_room CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_court_room_bir_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event     varchar(1) := 'I';
  l_modifying_user varchar(30);

BEGIN

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY_COURT_ROOM') = 1) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   l_modifying_user
;

    INSERT INTO AUD_DISPLAY_COURT_ROOM
    VALUES (NEW.DISPLAY_ID,
            NEW.COURT_ROOM_ID,
            l_modifying_user,
            l_trig_event);

  END IF;
  
    IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_court_room_bir_tr() FROM PUBLIC;


DROP TRIGGER IF EXISTS xhb_display_court_room_bur_tr ON xhb_display_court_room CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_court_room_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY_COURT_ROOM') = 1) THEN

    INSERT INTO AUD_DISPLAY_COURT_ROOM
    VALUES (OLD.DISPLAY_ID,
            OLD.COURT_ROOM_ID,
            OLD.MODIFYING_USER,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.INSERT_EVENT,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_court_room_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_court_room_bir_tr
	BEFORE INSERT ON xhb_display_court_room FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_court_room_bir_tr();

DROP TRIGGER IF EXISTS xhb_display_document_bir_tr ON xhb_display_document CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_document_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.DISPLAY_DOCUMENT_ID IS NULL THEN

    SELECT nextval('xhb_display_document_seq')
    INTO STRICT   NEW.DISPLAY_DOCUMENT_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_document_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_document_bir_tr
	BEFORE INSERT ON xhb_display_document FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_document_bir_tr();

DROP TRIGGER IF EXISTS xhb_display_document_bur_tr ON xhb_display_document CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_document_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY_DOCUMENT') = 1) THEN

    INSERT INTO AUD_DISPLAY_DOCUMENT(DISPLAY_DOCUMENT_ID,
            DESCRIPTION_CODE,
            DEFAULT_PAGE_DELAY,
            MULTIPLE_COURT_YN,
            CREATED_BY,
            CREATION_DATE,
            LAST_UPDATED_BY,
            LAST_UPDATE_DATE,
            VERSION,
            COUNTRY,
            LANGUAGE,
            INSERT_EVENT)
    VALUES (OLD.DISPLAY_DOCUMENT_ID,
            OLD.DESCRIPTION_CODE,
            OLD.DEFAULT_PAGE_DELAY,
            OLD.MULTIPLE_COURT_YN,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
	    OLD.COUNTRY,
	    OLD.LANGUAGE,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_document_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_document_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_display_document FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_document_bur_tr();

DROP TRIGGER IF EXISTS xhb_display_location_bir_tr ON xhb_display_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_location_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.DISPLAY_LOCATION_ID IS NULL THEN

    SELECT nextval('xhb_display_location_seq')
    INTO STRICT   NEW.DISPLAY_LOCATION_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_location_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_location_bir_tr
	BEFORE INSERT ON xhb_display_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_location_bir_tr();

DROP TRIGGER IF EXISTS xhb_display_location_bur_tr ON xhb_display_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_location_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY_LOCATION') = 1) THEN

    INSERT INTO AUD_DISPLAY_LOCATION
    VALUES (OLD.DISPLAY_LOCATION_ID,
            OLD.DESCRIPTION_CODE,
            OLD.COURT_SITE_ID,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_location_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_location_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_display_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_location_bur_tr();

DROP TRIGGER IF EXISTS xhb_display_type_bir_tr ON xhb_display_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_type_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.DISPLAY_TYPE_ID IS NULL THEN

    SELECT nextval('xhb_display_type_seq')
    INTO STRICT   NEW.DISPLAY_TYPE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_type_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_type_bir_tr
	BEFORE INSERT ON xhb_display_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_type_bir_tr();

DROP TRIGGER IF EXISTS xhb_display_type_bur_tr ON xhb_display_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_type_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY_TYPE') = 1) THEN

    INSERT INTO AUD_DISPLAY_TYPE
    VALUES (OLD.DISPLAY_TYPE_ID,
            OLD.DESCRIPTION_CODE,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_type_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_type_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_display_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_display_type_bur_tr();

DROP TRIGGER IF EXISTS xhb_publicnotice_bir_tr ON xhb_public_notice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_publicnotice_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.PUBLIC_NOTICE_ID IS NULL THEN

    SELECT nextval('xhb_public_notice_seq')
    INTO STRICT   NEW.PUBLIC_NOTICE_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN
    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_publicnotice_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_publicnotice_bir_tr
	BEFORE INSERT ON xhb_public_notice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_publicnotice_bir_tr();

DROP TRIGGER IF EXISTS xhb_publicnotice_bur_tr ON xhb_public_notice CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_publicnotice_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_PUBLIC_NOTICE') = 1) THEN

    INSERT INTO AUD_PUBLIC_NOTICE
    VALUES (OLD.PUBLIC_NOTICE_ID,
            OLD.PUBLIC_NOTICE_DESC,
            OLD.COURT_ID,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
            OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            OLD.definitive_pn_id,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_publicnotice_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_publicnotice_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_public_notice FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_publicnotice_bur_tr();

DROP TRIGGER IF EXISTS xhb_rotation_sets_bir_tr ON xhb_rotation_sets CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_rotation_sets_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.ROTATION_SET_ID IS NULL THEN

    SELECT nextval('xhb_rotation_sets_seq')
    INTO STRICT   NEW.ROTATION_SET_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_rotation_sets_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_rotation_sets_bir_tr
	BEFORE INSERT ON xhb_rotation_sets FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_rotation_sets_bir_tr();

DROP TRIGGER IF EXISTS xhb_rotation_sets_bur_tr ON xhb_rotation_sets CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_rotation_sets_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_ROTATION_SETS') = 1) THEN

    INSERT INTO AUD_ROTATION_SETS
    VALUES (OLD.ROTATION_SET_ID,
            OLD.COURT_ID,
            OLD.DESCRIPTION,
            OLD.DEFAULT_YN,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_rotation_sets_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_rotation_sets_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_rotation_sets FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_rotation_sets_bur_tr();

DROP TRIGGER IF EXISTS xhb_rotation_set_dd_bir_tr ON xhb_rotation_set_dd CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_rotation_set_dd_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.ROTATION_SET_DD_ID IS NULL THEN

    SELECT nextval('xhb_rotation_set_dd_seq')
    INTO STRICT   NEW.ROTATION_SET_DD_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_rotation_set_dd_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_rotation_set_dd_bir_tr
	BEFORE INSERT ON xhb_rotation_set_dd FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_rotation_set_dd_bir_tr();

DROP TRIGGER IF EXISTS xhb_rotation_set_dd_bur_tr ON xhb_rotation_set_dd CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_rotation_set_dd_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_ROTATION_SET_DD') = 1) THEN

    INSERT INTO AUD_ROTATION_SET_DD
    VALUES (OLD.ROTATION_SET_DD_ID,
            OLD.ROTATION_SET_ID,
            OLD.DISPLAY_DOCUMENT_ID,
            OLD.PAGE_DELAY,
            OLD.ORDERING,
            OLD.CREATED_BY,
            OLD.CREATION_DATE,
            OLD.LAST_UPDATED_BY,
            OLD.LAST_UPDATE_DATE,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_rotation_set_dd_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_rotation_set_dd_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_rotation_set_dd FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_rotation_set_dd_bur_tr();


DROP TRIGGER IF EXISTS xhb_pdda_dl_notifier_bir_tr ON xhb_pdda_dl_notifier CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_pdda_dl_notifier_bir_tr() RETURNS trigger AS $BODY$
BEGIN

  IF NEW.PDDA_DL_NOTIFIER_ID IS NULL THEN

    SELECT nextval('xhb_pdda_dl_notifier_seq')
    INTO STRICT   NEW.PDDA_DL_NOTIFIER_ID
;

  END IF;

  IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
           coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY,
           NEW.CREATED_BY
;

  END IF;

  SELECT LOCALTIMESTAMP,
         LOCALTIMESTAMP,
         1
  INTO STRICT   NEW.LAST_UPDATE_DATE,
         NEW.CREATION_DATE,
         NEW.VERSION
;

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_pdda_dl_notifier_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_pdda_dl_notifier_bir_tr
	BEFORE INSERT ON xhb_pdda_dl_notifier FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_pdda_dl_notifier_bir_tr();

DROP TRIGGER IF EXISTS xhb_pdda_dl_notifier_bur_tr ON xhb_pdda_dl_notifier CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_pdda_dl_notifier_bur_tr() RETURNS trigger AS $BODY$
DECLARE

  l_trig_event varchar(1) := NULL;
BEGIN
  BEGIN

  /* Determine whether UPDATING or DELETING */

  IF TG_OP = 'UPDATE' THEN

    l_trig_event := 'U';

    /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

      IF (OLD.VERSION != NEW.VERSION) THEN
      /* Someone has pulled the rug out from below! */

        RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50005';

      END IF;

    END IF;

    SELECT OLD.VERSION + 1,
           LOCALTIMESTAMP
    INTO STRICT   NEW.VERSION,
           NEW.LAST_UPDATE_DATE
;

    /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

    IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

      SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
      INTO STRICT   NEW.LAST_UPDATED_BY
;

    END IF;

  ELSE -- Must be DELETING
    l_trig_event := 'D';

  END IF;

  /* Is Auditing on this table required */

  IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_PDDA_DL_NOTIFIER') = 1) THEN

    INSERT INTO AUD_PDDA_DL_NOTIFIER
    VALUES (OLD.PDDA_DL_NOTIFIER_ID,
            OLD.COURT_ID,
            OLD.LAST_RUN_DATE,
            OLD.STATUS,
            OLD.ERROR_MESSAGE,
            OLD.OBS_IND,
            OLD.LAST_UPDATE_DATE,
            OLD.CREATION_DATE,
            OLD.CREATED_BY,
			OLD.LAST_UPDATED_BY,
            OLD.VERSION,
            l_trig_event);

  END IF;

  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_pdda_dl_notifier_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_pdda_dl_notifier_bur_tr
	BEFORE UPDATE OR DELETE ON xhb_pdda_dl_notifier FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_xhb_pdda_dl_notifier_bur_tr();


DROP TRIGGER IF EXISTS xhb_display_store_bir_tr ON xhb_display_store CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_store_bir_tr() RETURNS trigger AS $BODY$
BEGIN

IF NEW.DISPLAY_STORE_ID IS NULL THEN

  SELECT nextval('xhb_display_store_seq')
  INTO STRICT   NEW.DISPLAY_STORE_ID
;

END IF;

IF ((NEW.LAST_UPDATED_BY IS NULL) OR (NEW.CREATED_BY IS NULL)) THEN

  SELECT coalesce(current_setting('SESSION_USER', true),'PDDA'),
         coalesce(current_setting('SESSION_USER', true),'PDDA')
  INTO STRICT   NEW.LAST_UPDATED_BY,
         NEW.CREATED_BY
;

END IF;

SELECT LOCALTIMESTAMP,
       LOCALTIMESTAMP,
       1
INTO STRICT   NEW.LAST_UPDATE_DATE,
       NEW.CREATION_DATE,
       NEW.VERSION
;

RETURN NEW;
END
$BODY$
LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_store_bir_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_store_bir_tr
BEFORE INSERT ON xhb_display_store FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_xhb_display_store_bir_tr();

DROP TRIGGER IF EXISTS xhb_display_store_bur_tr ON xhb_display_store CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_xhb_display_store_bur_tr() RETURNS trigger AS $BODY$
DECLARE

l_trig_event varchar(1) := NULL;
BEGIN
BEGIN

/* Determine whether UPDATING or DELETING */

IF TG_OP = 'UPDATE' THEN

  l_trig_event := 'U';

  /* If the user is the connection pool user as defined in XHB_SYS_USER_INFORMATION */

  IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 1) THEN

    IF (OLD.VERSION != NEW.VERSION) THEN
    /* Someone has pulled the rug out from below! */

      RAISE EXCEPTION 'optimistic_lock_prob' USING ERRCODE = '50011';

    END IF;

  END IF;

  SELECT OLD.VERSION + 1,
         LOCALTIMESTAMP
  INTO STRICT   NEW.VERSION,
         NEW.LAST_UPDATE_DATE
;

  /* If the user is not the connection pool user as defined in XHB_SYS_USER_INFORMATION */

  IF (XHB_CUSTOM_PKG.IS_CONNECTION_POOL_USER() = 0) THEN

    SELECT coalesce(current_setting('SESSION_USER', true),'PDDA')
    INTO STRICT   NEW.LAST_UPDATED_BY
;

  END IF;

ELSE -- Must be DELETING
  l_trig_event := 'D';

END IF;

/* Is Auditing on this table required */

IF (XHB_CUSTOM_PKG.IS_AUDIT_REQUIRED('XHB_DISPLAY_STORE') = 1) THEN

  INSERT INTO AUD_DISPLAY_STORE
  VALUES (OLD.DISPLAY_STORE_ID,
          OLD.RETRIEVAL_CODE,
          OLD.CONTENT,
          OLD.OBS_IND,
          OLD.LAST_UPDATE_DATE,
          OLD.CREATION_DATE,
          OLD.CREATED_BY,
          OLD.LAST_UPDATED_BY,
          OLD.VERSION,
          l_trig_event);

END IF;

END;
IF TG_OP = 'DELETE' THEN
RETURN OLD;
ELSE
RETURN NEW;
END IF;

END
$BODY$
LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_xhb_display_store_bur_tr() FROM PUBLIC;

CREATE TRIGGER xhb_display_store_bur_tr
BEFORE UPDATE OR DELETE ON xhb_display_store FOR EACH ROW
EXECUTE PROCEDURE trigger_fct_xhb_display_store_bur_tr();
